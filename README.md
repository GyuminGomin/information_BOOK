# 정처기 필수 암기 363선

## 제 1 과목 소프트웨어 설계

### 소프트웨어 공학
- 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문
- 소프트웨어의 개발, 운용, 유지보수에 대한 체계적인 접근 방법
- 소프트웨어의 품질과 생산성을 향상시킬 목적
- 경제적인 비용을 들여 신뢰성 높은 소프트웨어를 개발하기 위해 공학적 원리를 정립하고 이를 적용하는 것

### 소프트웨어 공학의 기본 원칙
- 현대적인 프로그래밍 기술을 계속적으로 적용해야 함
- 개발된 소프트웨어 품질이 유지되도록 지속적으로 검증해야 함
- 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록 유지

### 폭포수 유형 (Waterfall Model)
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저히 검토해 승인 과정을 거친 후 다음 단계 진행하는 개발 방법론
- 보헴(Boehm)이 제시한 고전적 생명 주기 모형
- 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형
- 개발 과정에서 발생하는 요구사항 반영 어려움

### 나선형 모형 (Sprial Model, 점진적모형)
- 보헴이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 나선을 따라 돌듯 여러 번의 소프트웨어 개발 과정을 거쳐 점전직으로 완벽한 최종 소프트웨어를 개발하는 것
- `계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가` 과정이 반복적으로 수행됨

### 애자일 모형(Agile Model)
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하며 개발 과정을 진행
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
    - 스크럼(Scrum)
    - XP(eXtreme Programming)
    - 칸반(Kanban)
    - 린(Lean)
    - 크리스탈(Crystal)
    - ASD(Adaptive Software Development)
    - 기능 중심 개발(FDD; Feature Driven Development)
    - DSDM(Dynamic System Development Method)
    - DAD(Disciplined Agile Delivery)

### 애자일 개발 4가지 핵심 가치
- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 더 가치를 둠
- 계약 협상보다는 고객과 협업에 더 가치를 둠
- 계획을 따르기 보단 변화에 반응하는 것이 더 가치 있음

### 스크럼(Scrum) 기법의 주요 용어
- 스크럼 마스터(Scrum Master)
    - 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할
- 제품 백로그(Product Backlog)
    - 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함됨
- 스프린트(Sprint)
    - 하나의 완성된 최종 결과물을 만들기 위한 주기로 보통 2 ~ 4주 정도의 기간 내에서 진행함
- 속도(Velocity)
    - 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치

### XP(eXtreme Programming)
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화해 개발 생산성을 향상시키는 방법
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적
- 릴리즈의 기간을 짧게 반복하며 고객의 요구사항 반영에 대한 가시성을 높임
- 릴리즈 테스트마다 고객을 직접 참여시킴으로써 요구한 기능이 제대로 작동하는지 고객이 직접 확인할 수 있음
- 비교적 소규모 인원의 개발 프로젝트에 효과적
- 자동화된 테스팅 도구를 사용해 테스트를 지속적으로 수행
- 구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스 코드에 중점을 둠

### XP의 핵심 가치
- 의사소통(Communication)
- 단순성(Simplicity)
- 용기(Courage)
- 존중(Respect)
- 피드백(Feedback)

### XP의 주요 실천 방법
- Pair Programming(짝 프로그래밍)
    - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성
- Collective Ownership(공동 코드 소유)
    - 개발 코드에 대한 권한과 책임을 공동으로 소유함
- Continuous Integration(지속적인 통합)
    - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 완료될 때마다, 지속적으로 통합됨
- Refactoring(리팩토링)
    - 프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템의 내부 구조를 재구성

### 현행 시스템 파악 절차
- 1단계 : 시스템 구성, 시스템 기능, 시스템 인터페이스 파악
- 2단계 : 아키텍처 구성, 소프트웨어(DBMS, 운영체제 등) 구성 파악
- 3단계 : 하드웨어 구성, 네트워크 구성 파악

### DBMS 분석 시 고려사항
- 가용성
- 성능
- 기술 지원
- 상호 호환성
- 구축 비용

### WAS(Web Application Server)
- 정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
- 종류 : Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등

### 비 기능 요구사항
- 성능 요구사항 : 처리 속도 및 시간, 처리량 등의 요구사항
- 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구사항
- 품질 요구사항 : 품질 평가 대상에 대한 요구사항

### 요구사항 개발 프로세스
```
도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
```

### 요구사항 분석
- 소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화(명세화) 하는 활동을 의미
- 사용자의 요구를 정확하게 추출해 목표를 정하고, 어떤 방식으로 해결할 것인지를 결정
- 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정
- 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 사용자의 요구사항은 예외가 많고 지속적으로 변하므로 열거와 구조화가 어려움
- 내용이 중복되거나 하나로 통합되어야 하는 등 서로 상충되는 요구사항이 있으면 이를 중재하는 과정
- 요구사항 분석을 위해 UML(Unified Modeling Language), 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등의 도구 이용

### 기능 요구사항
- 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
- 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

### 요구사항 명세 기법
```
구분        |       정형 명세 기법      |       비정형 명세 기법        |
기법        | 수학적 원리 기반          | 상태/기능/객체 중심
            | 모델 기반                | 
작성 방법   | 수학적 기호, 정형화된 표기법| 자연어를 기반으로 작성
            |                          | 다이어그램으로 작성
특징        | 요구사항 정확, 간결 표현  | 일관성이 떨어짐
            |                          | 의사소통이 용이함
종류        | VDM,Z,Petri-net,CSP 등   | FSM, Decision Table, ER 모델링, 
            |                           | State Chart(SADT) 등
```

### 요구사항 확인(요구사항 검증)
- 분석가가 요구사항을 정확하게 이해한 후 요구사항 명세서를 작성했는지 확인(Validation)하는 것이 필요
- 요구사항이 실제 요구를 반영하는지, 서로 상충되는 요구사항은 없는지 등을 점검
- 개발이 완료된 후, 문제가 발견되면 재작업 비용이 발생할 수 있으므로 요구사항 검증은 매우 중요
- 요구사항 검증 과정을 통해 모든 문제를 확인할 수 있는 것은 아님

### 자료 흐름도의 구성 요소
<table>
    <tr> 
        <th>기호</th>
        <th>의미</th>
    </tr>
    <tr> 
        <td>프로세스(Process)</td>
        <td>- 자료를 변환시키는 시스템의 한 부분(처리 고정)을 나타내며 처리, 기능, 변환, 버블이라고도 함 <br/>
        - 원이나 둥근 사각형으로 표시하고 그 안에 프로세스 이름을 기입함</td>
    </tr>
    <tr> 
        <td>자료 흐름(Data Flow)</td>
        <td>- 자료의 이동(흐름)인 연관관계를 나타냄 <br/>
        - 화살표(->)위에 자료의 이름을 기입함</td>
    </tr>
    <tr> 
        <td>자료 저장소(Data Store)</td>
        <td>- 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냄 <br/>
        - 평행성(=) 안에 자료 저장소 이름을 기입함</td>
    </tr>
    <tr> 
        <td>단말(Terminator)</td>
        <td>- 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음(정보의 생산자와 소비자) <br/>
        - 사각형 안에 이름을 기입함</td>
    </tr>
</table>

### 자료 사전의 표기 기호
```
기호           |        의미
=              | 자료의 정의 : ~로 구성되어 있다(is composed of)
+              | 자료의 연결 : 그리고(and)
()             | 자료의 생략 : 생략 가능한 자료(Optional)
[|]            | 자료의 선택 : 또는(or)
{}             | 자료의 반복 : Iteration of
* *            | 자료의 설명 : 주석(Comment)
```

### SADT
- SoftTech 사에서 개발한 구조적 분석 및 설계 도구
- 블록 다이어그램을 채택한 자동화 도구

### UML
- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간 의사소통이 원할하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
- UML 다이어그램 종류
    - 구조적 다이어그램
        - 클래스 다이어그램 : 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
        - 객체 다이어그램 : 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
        - 컴포넌트 다이어그램 : 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
        - 배치 다이어그램 : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
        - 복합체 구조 다이어그램 : 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현
        - 패키지 다이어그램 : 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현
    - 행위 다이어그램
        - 유스케이스 다이어그램 : 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
        - 시퀀스 다이어그램 : 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
        - 커뮤니케이션 다이어그램 : 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고 받는 메시지를 표현하는데, 메시지 뿐 아니라 객체들 간의 연관관계 까지 표현
        - 상태 다이어그램 : 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지를 표현
        - 활동 다이어그램 : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
        - 상호작용 개요 다이어그램 : 상호작용 다이어그램 간의 제어 흐름을 표현
        - 타이밍 다이어그램 : 객체 상태 변화와 시간 제약을 명시적으로 표현
- 구성 요소 : 사물(Things), 관계(Relationships), 다이어그램(Diagram)

### HIPO
- 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
- 하향식 소프트웨어 개발을 위한 문서화 도구
- 기호, 도표 등을 사용하므로 보기 쉽고 이해가 쉬움
- 기능과 자료의 의존 관계를 동시 표현 가능
- 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 함
- HIPO Chart의 종류 : 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)

### 의존(Dependency) 관계
- 연관 관계와 같이 사물 사이 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 의미
- 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우 나타나는 관계

### 실체화(Realization) 관계
- 사물이 할 수 있거나 해야 하는 기능(오퍼레이션, 인터페이스)로 서로를 그룹화 할 수 있는 관계를 표현
- 한 사물이 다른 사물에게 오퍼레이션을 수행하도록 지정하는 의미적 관계

### 일반화(Generalization) 관계
- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
- 예를 들어 차는 버스, 트럭, 택시보다 일반적인 개념이고 반대로 버스, 트럭, 택시는 차보다 구체적인 개념

### 스테레오 타입(Stereotype)
- UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용
- 길러멧(Guilemet)이라고 부르는 겹화살괄호(<<>>) 사이에 표현할 형태를 기술

### 구조적(정적) 다이어그램
- 클래스 다이어그램
    - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현하며, 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있음
- 객체(Object) 다이어그램
    - 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현하며, 구현 단계에서 사용됨
- 컴포넌트 다이어그램
    - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현하며, 구현 단계에서 사용됨
- 배치(Deployment) 다이어그램
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현하며, 구현 단계에서 사용됨
- 복합체 구조(Composite Structure) 다이어그램
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함
- 패키지 다이어그램
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

### 사용자 인터페이스(UI)의 특징
- 사용자의 편리성과 가독성을 높임으로써 작업 시간을 단축시키고 업무에 대한 이해도를 높여줌
- 사용자 중심으로 설계되어 사용자 중심의 상호 작용이 되도록 함
- 수행 결과의 오류를 줄임
- 사용자의 막연한 작업 기능에 대해 구체적인 방법을 제시해 줌

### 행위(동적) 다이어그램
- 유스케이스 다이어그램
    - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
- 순차(Sequence) 다이어그램
    - 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
- 커뮤니케이션 다이어그램
    - 순차 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현
- 상태(State) 다이어그램
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현하는 것으로, 럼바우 객체지향 분석 기법에서 동적 모델링에 활용
- 활동(Activity) 다이어그램
    - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현함
- 상호작용 개요(Interaction Overview) 다이어그램
    - 상호작용 다이어그램 간 제어 흐름을 표현
- 타이밍 다이어그램
    - 객체 상태 변화와 시간 제약을 명시적으로 표현

### 유스케이스 다이어그램의 구성 요소
- 시스템 / 시스템 범위
    - 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
- 액터  
`시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미`  
    - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당
    - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있음
- 유스케이스
    - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현
- 관계(Relationship)
    - 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며, 연관 관계, 포함 관계, 확장 관계, 일반화 관계를 표현할 수 있음
    - 연관 관계 : 2개 이상의 사물이 서로 관련되어 있음
    - 집합 관계 : 하나의 사물이 다른 사물에 포함되어 있는 관계
    - 포함 관계 : 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
    - 일반화 관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현하는 관계
    - 의존 관계 : 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
    - 실체화 관계 : 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계
    - 확장 관계

### 오퍼레이션(Operation)
- 클래스가 수행할 수 있는 동작으로, 함수(메소드)라고도 함

### 순차 다이어그램의 구성 요소
- 액터(Actor)
- 객체(Object)
- 생명선(Lifeline)
- 실행 상자(Active Box)
- 메시지(Message)

### 사용자 인터페이스의 구분
- CLI(Command Line Interface)
    - 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphic User Interface)
    - 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface)
    - 사용자의 말이나 행동으로 기기를 조작하는 인터페이스

- 인터페이스에 포함되는 사항
    - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 프로세서나 하드웨어
    - 운영체제, 서브루틴 패키지와 같이 새로운 소프트웨어에 연결되어야 하는 소프트웨어
    - 키보드나 기타 I/O 장치들을 통해 소프트웨어를 사용하는 사람
    - 순서적인 연산에 의해 소프트웨어를 실행하는 절차

### UI 설계 도구
- 와이어 프레임(Wireframe) : 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 단계
- 목업(Mockup)
    - 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임 보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
    - 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않음
- 스토리보드(Story Board) : 와이어 프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서
- 프로토타입(Prototype) : 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- 유스케이스(Use Case) : 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한 것


### 주요 모바일 제스처(Mobile Gesture)
- Tap(누르기)
    - 화면을 가볍에 한 번 터치하는 동작
- Double Tap(두번 누르기)
    - 화면을 빠르게 두 번 터치하는 동작
- Press(오래 누르기)
    - 화면의 특정 위치를 손가락으로 꾹 눌리는 동작
- Flick(빠르게 스크롤)
    - 화면에 손가락을 터치하면서 수평 또는 수직으로 빠르게 드래그하는 동작
- Pinch(두 손가락으로 넓히기/좁히기)
    - 두 손가락으로 화면을 터치한 후 두 손가락을 서로 다른 방향으로 움직이는 동작

### 사용자 인터페이스의 원칙 - 직관성
- 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙

### 사용자 인터페이스 설계 지침
- 사용자 중심
    - 사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경을 제공하며, 실사용자에 대한 이해가 바탕이 되어야 함
- 사용성
    - 사용자가 소프트웨어를 얼마나 빠르고 쉽게 이해할 수 있는지, 얼마나 편리하고 효율적으로 사용할 수 있는지를 말하는 것으로, 사용자 인터페이스 설계시 가장 우선적으로 고려해야 함
- 가시성
    - 메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계해야 함
- 심미성
    - 디자인적으로 완성도 높게 글꼴이나 색상을 적용하고 그래픽 요소를 배치하여 가독성을 높일 수 있도록 설계해야 함
- 접근성
    - 사용자의 연령, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계해야 함
- 오류 발생 해결
    - 오류가 발생하면 사용자가 쉽게 인지할 수 있도록 설계해야 함

### ISO/IEC 12119
- ISO/IEC 9126을 준수한 품질 표준, 테스트 절차를 포함하여 규정
- 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준

### 소프트웨어 품질 특성 - 기능성(Functionality)
- 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄
- 하위 특성
    - 적절성/적합성, 정밀성/정확성, 상호운용성, 보안성, 준수성

### 소프트웨어 품질 특성 - 신뢰성(Reliability)
- 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도를 나타냄

### 소프트웨어 품질 특성 - 사용성(Usability)
- 사용자와 컴퓨터 사이 발생하는 어떤 행위에 대해 사용자가 쉽게 배우고 사용할 수 있으며, 향후 다시 사용하고 싶은 정도를 나타냄

### 소프트웨어 품질 특성 - 이식성(Portability)
- 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타냄

### UI 요소 - 라디오 버튼
- 여러 항목 중 하나만 선택할 수 있는 사용자 인터페이스 요소

### 소프트웨어 아키텍처의 설계 과정
```
설계 목표 설정 -> 시스템 타입 결정 -> 아키텍처 패턴 적용 -> 서브시스템 구체화 -> 검토
```

### 모듈화(Modularity)
- 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
- 모듈화를 통해 기능의 분리가 가능하여 인터페이스가 단순해진다.
- 모듈화를 통해 프로그램의 효율적인 관리가 가능하고 오류의 파급 효과를 최소화 가능
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 듬

### 추상화의 유형
- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.
- 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.
- 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.
- 과정 추상화 : 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
- 데이터(자료) 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
- 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

### 파이프 - 필터 패턴
- 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
- 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생

### MVC(Model-View-Controller) 패턴
- 모델
    - 서브시스템의 핵심 기능과 데이터를 보관
- 뷰
    - 사용자에게 정보를 표시
- 컨트롤러
    - 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

### 메시지(Message)
- 객체들 간 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항

### 클래스(Class)
- 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라 함

### 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음
- 캡슐화를 수행하면 인터페이스가 단순해짐
- 캡슐화된 객체들은 재사용이 용이

### 상속(Inheritance)
- 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것

### 객체지향 분석 방법론 
- Coad와 Yourdon 방법
    - E-R 다이어그램을 사용해 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
- Rumbaugh 방법
    - 가장 일반적으로 사용되는 방법으로, 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법
- Booch(부치) 방법
    - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
- Wirfs-Brock 방법
    - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해 설계 작업까지 연속적으로 수행하는 기법

### 럼바우(Rumbaugh)의 분석 기법
- 객체(Object) 모델링
    - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
- 동적(Dynamic) 모델링
    - 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
- 기능(Functional) 모델링
    - 자료 흐름도(DFD)를 이용해 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체지향 설계 원칙(SOLID) 원칙
- 단일 책임 원칙(SRP; Single Responsibility Principle)
    - 객체는 단 하나의 책임만 가져야 한다는 원칙으로, 응집도는 높고, 결합도는 낮게 설계하는 것을 의미
- 개방 폐쇄 원칙(OCP; Open-Closed Principle)
    - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙으로, 공통 인터페잇를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적
- 리스코프 치환 원칙(LSP; Liskov Substitution Principle)
    - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙으로, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야함
- 인터페이스 분리 원칙(ISP; Interface Segregation Principle)
    - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙으로, 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임
- 의존 역전 원칙(DIP; Dependency Inversion Principle)
    - 각 객체들 간 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙으로, 일반적으로 인터페이스를 활용하면 이 원칙은 준수됨

### 모듈(Module)
- 모듈화를 통해 분리된 시스템의 각 기능들로, 서브 루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨
- 모듈은 단독으로 컴파일이 가능하며, 재사용 할 수 있음
- 모듈은 다른 모듈에서의 접근이 가능

### 결합도의 종류
- 자료(Data) 결합도
    - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
- 스탬프(Stamp) 결합도
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
- 제어(Control) 결합도
    - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용해 통신하거나 제어 요소를 전달하는 결합도
- 외부(External) 결합도
    - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
- 공통(Common) 결합도
    - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
- 내용(Content) 결합도
    - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

### 결합도의 정도(약함->강함)
```
자료 결합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도
```

### 응집도의 정도(약함->강함)
```
우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 교환적 응집도 -> 순차적 응집도 -> 기능적 응집도
```

### 응집도의 종류
- 기능적(Functional) 응집도
    - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
- 순차적(Sequential) 응집도
    - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
- 교환적(Communication) 응집도
    - 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
- 절차적(Procedural) 응집도
    - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- 시간적(Temporal) 응집도
    - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
- 논리적(Logical) 응집도
    - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
- 우연적(Coincidental) 응집도
    - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

### N-S 차트(Nassi-Schneiderman Chart)
- 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고도 함
- 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현
- GOTO나 화살표를 사용하지 않음
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
- 선택과 반복 구조를 시각적으로 표현
- 읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 전이하는 것이 불가능
- 총체적인 구조 표현과 인터페이스를 나타내기가 어려움
- 단일 입구와 단일 출구로 표현함
- 이해하기 쉽고, 코드 변환이 용이

### 재사용(Reuse)
- 이미 개발된 기능을 새로운 시스템이나 기능 개발에 사용할 수 있는 정도를 의미
- 재사용 규모에 따른 분류
    - 함수와 객체, 컴포넌트, 애플리케이션
    - 컴포넌트
        - 독립적인 업무 또는 기능을 수행하는 실행코드 기반으로 작성된 모듈
        - 컴포넌트는 문서, 소스코드, 파일, 라이브러리 등과 같은 모듈화된 자원으로, 재사용이 가능하다.

### 팬인(Fan-In) / 팬아웃(Fan-Out)
- 팬인
    - 어떤 모듈을 제어(호출)하는 모듈의 수
- 팬아웃
    - 어떤 모듈에 의해 제어(호출)되는 모듈의 수

### 효과적인 모듈 설계 방안
- 결합도는 줄이고 응집도는 높여 모듈의 독립성과 재사용성을 높임
- 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지 시킴
- 복잡도의 중복성을 줄이고 일관성을 유지
- 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안됨
- 유지보수가 용이해야 함

### 디자인 패턴(Design Pattern)
- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
- 소프퉤어에 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법
- 디자인 패턴 유형
    - 생성 패턴, 구조 패턴, 행위 패턴

### 생성 패턴(Creational Pattern)
- 추상 팩토리(Abstract Factory)
    - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 빌더(Builder)
    - 작게 분리된 인스턴스를 건축 하듯 조합하여 객체를 생성
- 팩토리 메서드(Factory Method)
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화된 패턴으로, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당. 가상 생성자(Virtual Constructor)패턴 이라고도 함
- 프로토 타입(Prototype)
    - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤(Singleton)
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음

### 구조 패턴(Structural Pattern)
- 어댑터(Adapter)
    - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지(Bridge)
    - 구현부에서 최상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트(Composite)
    - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 데코레이터(Decorator)
    - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴으로, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
- 퍼싸드(Facade)
    - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 플라이웨이트(Flyweight)
    - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 프록시(Proxy)
    - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

### 행위 패턴(Behavioral Pattern)
- 책임 연쇄(Chain of Responsibility)
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 커맨드(Command)
    - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 인터프리터(Interpreter)
    - 언어에 문법 표현을 정의하는 패턴으로, SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함
- 반복자(Iterator)
    - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자(Mediator)
    - 수많은 객체들 간 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
- 메멘토(Memento)
    - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있느 기능을 제공하는 패턴으로 Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 사용
- 옵저버(Observer)
    - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 상태(State)
    - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략(Strategy)
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 템플릿 메소드(Template Method)
    - 상위 클래스에서 골격을 정의하고, 하위 클래승서 세부 처리를 구체화하는 구조의 패턴
- 방문자(Visitor)
    - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

### 요구사항 검증 방법
- 동료검토(Peer Review)
    - 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으며 결함을 발견하는 형태의 검토 방법
- 워크스루(Walk Through)
    - 검토 회의 전 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법
    - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있음
    - 단순한 테스트 케이스를 이용해 프로덕트를 수작업으로 수행해 보는 것
- 인스펙션(Inspection)
    - 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하며 결함을 발견하는 형태의 검토 방법
    - 인스펙션 과정
        - 계획 -> 사전 교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속 조치
- 동료검토와 워크스루가 비공식적인 검토 방법인데 반해 인스펙션은 공식적인 검토 방법

### 미들웨어(Middleware)
- 분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신 환경 등을 연결
- 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 원만한 통신이 이루어지도록 다양한 서비스를 제공
- 표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장
- 위치 투명성을 제공
- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 함
- 시스템들을 1:1, 1:N, N:M 등 여러 가지 형태로 연결할 수 있음
- 종류 : DB, RPC, MOM, TP-Monitor, ORB, WAS 등
    - MOM(Message-Oriented Middleware)
        - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
        - 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용
        - 대표적인 MOM의 종류로는 IBM의 MQ, 오라클의 Message Q, JCP의 JMS 등이 있음
        - 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용
        - 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 함
        - 송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있음
        - 상이한 애플리케이션 간 통신을 비동기 방식으로 처리

## 제 2과목 소프트웨어 개발

### 자료 구조의 분류
- 선형 구조 : 배열(Array), 선형 리스트(Linear List), 스택(Stack), 큐(Queue), 데크(Deque)
- 비 선형 구조 : 트리(Tree), 그래프(Graph)

### 스택(Stack)
- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리

### 스택의 응용 분야
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀 주소 저장
- 서브루틴 호출 및 복귀 주소 저장

### 스택의 삽입(Push)과 삭제(Pop)
- PUSH는 스택에 자료를 입력하는 명령이고, POP은 스택에서 자료를 출력하는 명령

### 방향/무방향 그래프의 최대 간선 수
- n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2이고, 방향 그래프에서 최대 간선 수는 n(n-1)이다.

### 트리(Tree)
- 트리는 정점(Node)과 선분(Branch)을 이용해 사이클을 이루지 않도록 구성한 그래프의 특수한 형태임
    - 디그리(Degree, 차수) : 각 노드에서 뻗어나온 가지의 수
    - 단말 노드(Terminal Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드

### 수식의 표기법(Infix -> Postfix)
- Infix로 표기된 수식에서 연산자를 해당 피연산자 두 개의 뒤(오른쪽)에 오도록 이동하면 Postfix가 됨
```
X = A / B * (C + D) + E -> X A B / C D + * E + =

1. 연산 우선순위에 따라 괄호로 묶는다.
( X = ( ( (A / B) * (C + D) ) + E ) )
2. 연산자를 해당 괄호의 뒤로 옮긴다.
X = ( ( (A / B) * (C + D)) + E)
(A/B)에서 (AB)/
(C+D)에서 (CD)+
( (AB)/ * (C+D)+ )에서 (AB)/(C+D)*
이런 형태로 변경하면
( X ( ( (AB) / (CD) + ) * E ) + ) =
3. 괄호를 제거
X A B / C D + * E + =
```

### 이진 트리의 운행법
- Preorder 운행법의 방문 순서
    - Root -> Left -> Right
- Inorder 운행법의 방문 순서
    - Left -> Root -> Right
- Postorder 운행법의 방문 순서
    - Left -> Right -> Root

### 퀵 정렬(Quick Sort)
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬
- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬

### 삽입 정렬(Insertion Sort)
```
ex. 8, 5, 6, 2, 4를 삽입 정렬로 정렬하시오.
- 초기 상태 : 8 5 6 2 4
- 1 회전 : 8 [5] 6 2 4 -> 5 8 6 2 4
    - 두 번째 값 5를 첫 번째 값과 비교해 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킴
- 2 회전 : 5 8 [6] 2 4 -> 5 6 8 2 4
    - 세 번째 값 6을 첫 번째, 두 번째 값과 비교해 8자리에 삽입하고 8을 한 칸 뒤로 이동
- 3 회전 : 5 6 8 [2] 4 -> 2 5 6 8 4
    - 네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 한 칸 씩 뒤로 이동
- 4 회전 : 2 5 6 8 [4] -> 2 4 5 6 8
    - 마지막 값 4를 처음부터 비교하여 5 자리에 삽입하고 나머지를 한 칸씩 뒤로 이동
```

### 선택(Selection) 정렬
```
- n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬

ex. 8, 5, 6, 2, 4를 선택 정렬로 정렬하시오
- 초기 상태 : 8 5 6 2 4
- 1 회전 : [8] 5 6 2 4 -> [5] 8 6 2 4 -> [2] 8 6 5 4
- 2 회전 : 2 [8] 6 5 4 -> 2 [6] 8 5 4 -> 2 [5] 8 6 4 -> 2 [4] 8 6 5
- 3 회전 : 2 4 [8] 6 5 -> 2 4 [6] 8 5 -> 2 4 [5] 8 6
- 4 회전 : 2 4 5 [8] 6 -> 2 4 5 [6] 8
```

### 버블 정렬(Bubble Sort)
```
- 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환

ex. 8, 5, 6, 2, 4를 버블 정렬로 정렬하시오.
- 초기 상태 : 8 5 6 2 4
- 1 회전 : 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 -> 5 6 2 4 8
- 2 회전 : 5 6 2 4 | 8 -> 5 2 6 4 8 -> 5 2 4 6 8
- 3 회전 : 5 2 4 | 6 8 -> 2 5 4 6 8 -> 2 4 5 6 8
- 4 회전 : 2 4 | 5 6 8

| 앞에꺼만 버블정렬을 수행하면 되는 형태
```

### 힙 정렬 (Heap Sort)
- 전이진 트리를 이용한 정렬 방식
- 평균과 최악 모두 시간 복잡도는 O(nlog2n) 이다.

### 2-Way 합병 정렬(Merge Sort)
- 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
- 평균과 최악 모두 시간 복잡도는 O(nlog2n) 이다.

### 테스트와 디버깅의 목적
- 테스트(Test)를 통해 오류를 발견한 후 디버깅(Debugging)을 통해 오류가 발생한 소스 코드를 추적하며 수정

### 이분 검색(이진 검색)
- 반드시 순서화(정렬)된 파일이어야 검색 가능
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듬
- 탐색 효율이 좋고 탐색 시간이 적게 소요됨
- 중간 레코드 번호(M) : (F + L) / 2
    - 단, F : 첫 번째 레코드 번호, L : 마지막 레코드 번호

### 주요 해싱 함수
- 제산법(Division) : 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식
- 제곱법(Mid-Square) : 레코드 키 값(K)을 제곱한 후, 그 중간 부분의 값을 홈 주소로 삼는 방식
- 폴딩법(Folding) : 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
- 숫자 분석법(계수 분석법,Digit Analysis) : 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- 기수 변환법(Radix) : 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- 대수적 코딩법(Algebraic Coding) : 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
- 무작위법(Random) : 난수를 발생시켜 나온 값을 홈 주소로 삼는 방식

### 스키마 3 계층
- 외부 스키마
    - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 DB의 논리적 구조를 정의한 것
- 개념 스키마
    - DB의 전체적인 논리적 구조로서, 개체 간의 관계와 제약 조건을 나타내고, DB의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
- 내부 스키마
    - 물리적 저장장치의 입장에서 본 DB의 구조로서, 실제로 DB에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

### IDE(통합 개발 환경)의 기능
- 코딩(Coding)
    - C, JAVA 등의 프로그래밍 언어로 컴퓨터 프로그램을 만드는 기능
- 컴파일(Compile)
    - 개발자가 작성한 고급 언어로 된 프로그램을 컴퓨터가 이해할 수 있는 목적 프로그램으로 번역하여 컴퓨터에서 실행 가능한 형태로 변환하는 기능
- 디버깅(Debugging)
    - 소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 버그(Bug)를 찾아 수정하는 기능
- 배포(Deployment)
    - 소프트웨어를 사용자에게 전달하는 기능

### 빌드 자동화 도구
- Ant
    - 아파치 소프트웨어 재단에서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용됨
- Maven
    - Ant의 대안으로 개발된 소프트웨어
- Jenkins
    - JAVA 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구
- Gradle
    - Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구로, 안드로이드 앱 개발 환경에서 사용

### 소프트웨어 패키징
- 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말함
- 개발자가 아니라 사용자 중심으로 진행

### 소프트웨어 패키징 시 고려사항
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 암호화 및 보안을 고려함
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려함

### DRM(디지털 저작권 관리, Digital Rights Management)의 구성 요소
- 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
- 클리어링 하우스(Clearing House)
    - 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제 관리 등을 수행하는 곳
- 콘텐츠 제공자(Contents Provider)
    - 콘텐츠를 제공하는 저작권자
- 패키저(Packager)
    - 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- 콘텐츠 분배자(Contents Distributor)
    - 암호화된 콘텐츠를 유통하는 곳이나 사람
- DRM 컨트롤러(DRM Controller)
    - 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
- 보안 컨테이너(Security Container)
    - 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

### DRM(디지털 저작권 관리)의 기술 요소
- 암호화
    - 콘텐츠 및 라이선스 암호화 기술
- 키 관리
    - 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- 식별 기술
    - 콘텐츠에 대한 식별 체계 표현 기술
- 정책 관리
    - 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- 크랙 방지
    - 크랙에 의한 콘텐츠 사용 방지 기술

### 소프트웨어 설치 매뉴얼
- 설치 매뉴얼은 사용자를 기준으로 작성함
- 기본 사항 : 소프트웨어 개요, 설치 관련 파일, 설치 아이콘, 프로그램 삭제, 관련 추가 정보

### 소프트웨어 사용자 매뉴얼 작성 순서
```
작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토
```

### 형상 관리(SCM)
- 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동
- 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보충하는 것을 목적으로 함
- 관리 항목
    - 소스 코드, 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 등
- 형상 관리 도구
    - Git, CVS, Subversion 등

### 형상 관리 기능
- 형상 식별
    - 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분해 수정 및 추적이 용이하도록 하는 작업
- 버전 제어
    - 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구를 결합시키는 작업
- 형상 통제
    - 식별된 형상 항목에 대한 변경 요구를 검토 해 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업
- 형상 감사
    - 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- 형상 기록
    - 형상의 식별, 통제, 감사 작업의 결과를 기록-관리하고 보고서를 작성하는 작업

### 소프트웨어의 버전 등록 관련 주요 기능
- 체크아웃(Check-Out)
    - 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아옴
- 체크인(Check-In)
    - 체크아웃 한 파일의 수정을 완료한 후 저장소(Repository)의 파일을 새로운 버전으로 갱신함
- 커밋(Commit)
    - 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료

### RCS(Revision Control System)
- 여러 개발자가 프로젝트를 수행할 때 시간에 따른 파일 변화 과정을 관리하는 소프트웨어 버전 관리 도구
- 소스 파일을 동시에 수정하는 것을 방지하고, 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적 할 수 있음

### 분산 저장소 방식
- 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
- 대표적인 종류에는 Git이 있음

### 확인(Validation) / 검증(Verification)
- 확인(Validation)
    - 사용자의 입장에서 개발한 소프트웨어가 고객의 요구사항에 맞게 구현되었는지를 확인하는 것
- 검증(Verification)
    - 개발자의 입장에서 개발한 소프트웨어가 명세서에 맞게 만들어졌는지를 점검하는 것

### 파레토 법칙(Pareto Principle)
- 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20%내에서 발견된다는 법칙

### 결함 집중
- 애플리케이션 대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것을 의미
- 파레토 법칙이 좌우함
- 결함은 발생한 모듈에서 계속 추가로 발생할 가능성이 높음

### 강도(Stress) 테스트
- 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트

### 화이트박스 테스트(White Box Test)
- 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계 하는 방법
- 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행됨
- 설계된 절차에 초점을 둔 구조적 테스트로 프로시저 설계의 제어 구조를 사용해 테스트 케이스를 설계하며, 테스트 과정의 초기에 적용됨
- 모듈 안의 작동을 직접 관찰
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어함
- 화이트박스 테스트의 이해를 위해 논리 흐름도(Logic Flow Diagram)를 이용할 수 있음
- 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당
- 테스트 데이터를 선택하기 위해 검증 기준(Test Coverage)을 정함

### 화이트박스/블랙박스 테스트 종류
- 화이트박스 테스트 종류
    - 기초 경로 검사, 제어 구조 검사(조건 검사, 루프 검사, 데이터 흐름 검사)
    - 기초 경로 검사(Base Path Testing) : 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
    - 제어 구조 검사(Control Structure Testing)
        - 조건 검사(Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트 하는 테스트 케이스 설계 기법
        - 루프 검사(Loop Testing) : 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
        - 데이터 흐름 검사(Data Flow Testing) : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
- 블랙박스 테스트
    - 블랙 박스 테스트
        - 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그래 또는 모듈의 요구나 명세를 기초로 결정
    - 블랙 박스 테스트 종류
        - 동치 분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사
- 기초 경로(Base Path = Basis Path)
    - 수행 가능한 모든 경로를 의미

### 단위 테스트(Unit Test)
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
- 단위 테스트로 발견 가능한 오류
    - 알고리즘 오류에 따른 원치 않는 결과, 탈출구가 없는 반복문의 사용, 틀린 계산 수식에 의한 잘못된 결과

### 인수 테스트의 종류
- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법
- 개발한 소프트웨어를 사용자가 직접 테스트함
- 테스트에 문제가 없으면 사용자는 소프트웨어를 인수하게 되고, 프로젝트는 종료
- 알파 테스트
    - 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법
- 베타 테스트
    - 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법으로, 필드 테스팅(Field Testing)이라고도 불림

### 통합 테스트
- 하향식 통합 테스트
    - 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법으로, 깊이 우선 통합법이나 넓이 우선 통합법을 사용
    - 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
    - 상위 모듈에서는 테스트 케이스를 사용하기 어려움
- 상향식 통합 테스트
    - 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
    - 가장 하위 단계의 모듈부터 통합 및 테스트가 수행되므로 스텁(Stub)은 필요하지 않지만, 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster)가 필요함

### 테스트 하네스(Test Harness)의 구성요소
- 테스트 드라이버
    - 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구
- 테스트 스텁
    - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
- 테스트 슈트
    - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
- 테스트 케이스
    - 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서
- 테스트 스크립트
    - 자동화된 테스트 실행 절차에 대한 명세서
- 목 오브젝트
    - 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

### 테스트 드라이버(Test Driver)
- 테스트 대상의 하위 모듈을 호출하는 도구로, 매개 변수(Parameter)를 전달하고, 모듈 테스트 수행 후의 결과를 도출
- 상위 모듈 없이 하위 모듈이 있는 경우 하위 모듈을 구동
- 상향식 통합 테스트에 사용

### 테스트 스텁(Test Stub)
- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
- 상위 모듈은 있지만 하위 모듈이 없는 경우 하위 모듈을 대체
- 하향식 통합 테스트에 사용

### 테스트 케이스(Test Case)
- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
- 테스트 케이스는 테스트 목표와 방법을 설정한 후 작성
- 가장 이상적인 테스트 케이스를 설계하려면 시스템 설계 시 작성해야 함

### 테스트 오라클
- 참(True) 오라클
    - 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클로, 발생된 모든 오류를 검출
- 샘플링(Sampling) 오라클
    - 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
- 추정(Heuristic) 오라클
    - 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- 일관성 검사(Consistent) 오라클
    - 애플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

### 테스트 케이스 생성 도구
- 자료 흐름도
    - 자료 원시 프로그램을 입력받아 파싱한 후 자료 흐름도를 작성
- 기능 테스트
    - 주어진 기능을 구동시키는 모든 가능한 상태를 파악해 이에 대한 입력 작성
- 입력 도메인 분석
    - 원시 코드의 내부를 참조하지 않고, 입력 변수의 도메인을 분석하여 테스트 데이터를 작성
- 랜덤 테스트
    - 입력 값을 무작위로 추출해 테스트

### 성능 테스트 도구(Performance Test Tools)
- 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부 확인

### 결함(Fault)
- 오류(Error) 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미

### 주요 최악의 시간 복잡도
```
O(1) - 입력값(n)에 관계 없이 일정하게 문제 해결에 하나의 단계 만을 거침
ex. 스택의 삽입(Push), 삭제(Pop)
O(nlog2n) - 문제 해결에 필요한 단계가 n(log2n)번 만큼 수행
ex. 힙 정렬(Heap Sort), 2-Way 합병 정렬(Merge Sort)
```

### 순환 복잡도(Cyclomatic Complexity) 계산
- 그림으로 확인

### 클린 코드 작성 원칙
- 가독성
    - 누구든지 코드를 쉽게 읽을 수 있도록
- 단순성
    - 코드를 간단하게 작성
- 의존성 배제
    - 코드가 다른 모듈에 미치는 영향을 최소화
- 중복성 최소화
    - 코드의 중복을 최소화
- 추상화
    - 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현

### 외계인 코드(Alien Code)
- 아주 오래되거나 참고문서 또는 개발자가 없어 유지 보수 작업이 어려운 코드를 의미

### 소스 코드 품질 분석 도구 - 정적 분석 도구
- 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인
- 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있음
- 비교적 애플리케이션 개발 초기의 결함을 찾는데 사용되고, 개발 완료 시점에서는 개발된 소스 코드의 품질을 검증하는 차원에서 사용
- 동적 분석 도구로는 찾기 어려운 결함을 찾아내고, 소스 코드에서 코딩의 복잡도, 모델 의존성, 불일치성 등을 분석 가능
- 종류
    - pmd, checkstyle, cppcheck, SonarQube, ccm,cobertura 등

### EAI의 구축 유형
- EAI(Enterprise Application Integration)
    - 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
- Point-to-Point
    - 애플리케이션을 1:1로 연결
- Hub & Spoke
    - 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
- Message Bus(ESB 방식)
    - 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
- Hybrid
    - Hub & Spoke와 Message Bus의 혼합 방식

### GPL, Duplexing
- GPL(General Public License)
    - 자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스
- Duplexing
    - 서비스 중단에 대비해 동일한 기능을 수행하는 예비 시스템을 동시에 운용하는 것

### JSON(JavaScript Object Notation)
- 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷

### AJAX(Asynchronous JavaScript and XML)
- 자바 스크립트 등을 이용해 클라이언트와 서버 간 XML 데이터를 교환 및 제어함으로써 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 하는 비동기 통신 기술을 의미

### IPSec(IP Security)
- 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
- 암호화와 복호화가 모두 가능한 양방향 암호 방식
- 발신지 인증, 무결성, 기밀성 등을 보장하는 ESP를 지원
- 발신지 호스트를 인증하고, 무결성을 보장하는 인증 헤더(AH)를 지원
- 두 게이트웨이 사이에서 IP 패킷 전체를 보호하는 터널 모드(Tunnel)와 두 호스트 사이에서 IP 헤더를 제외한 나머지 부분을 보호하는 전송 모드(Transport)로 구분

### 인터페이스 보안 기능 적용 - 네트워크 영역
- 인터페이스 송-수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정
- 암호화는 인터페이스 아키텍처에 따라 IPSec, SSL, S-HTTP 등의 다양한 방식으로 적용

### 데이터 무결성 검사 도구
- 시스템 파일의 변경 유무를 확인하고, 파일이 변경되었을 경우 이를 관리자에게 알려주는 도구
- 크래커 등이 시스템에 침입하면 백도어를 만들어 놓거나 시스템 파일을 변경해 자신의 흔적을 감추는데, 무결성 검사 도구를 이용해 이를 감지할 수 있음
- 종류
    - Tripwire, AIDE, Samhain 등

### 인터페이스 구현 검증 도구
- xUnit
    - JUnit, CppUnit,NUnit,HttpUnit 등 다양한 언어에 적용되는 단위 테스트 프레임워크
- STAF
    - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- FitNesse
    - 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
- NTAF
    - FitNesse와 STAF의 장점을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
- watir
    - Ruby를 사용하는 애플리케이션 테스트 프레임워크
- Selenium
    - 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임 워크

### 정형 기술 검토(FTR; Formal Technical Review)
- 정형 기술 검토는 가장 일반적인 검토 방법으로 소프트웨어 기술자들에 의해 수행되는 소프트웨어 품질 보증 활동
- 정형 기술 검토 유형에는 검토 회의(Walkthrough), 검열(Inspection) 등이 있으며 이는 모두 회의 형태로 수행된다.
- 정형 기술 검토의 지침 사항
    - 의제와 참가자의 수를 제한한다.
    - 제품의 검토에만 집중
    - 논쟁과 반박을 제한
    - 문제 영역 명확히 표시
    - 해결책이나 개선책에 대해서 논의 하지 않음
    - 사전 준비 강요
    - 검토될 확률이 있는 각 제품에 대한 체크 리스트를 개발

## 제 3과목 데이터베이스 구축

### 개념적 설계(정보 모델링, 개념화)
- 정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
- 개념적 설계 단계에선 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
- 개념적 설계 단계에선 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
- DBMS에 독립적인 개념 스키마를 설계

### 논리적 설계(데이터 모델링)
- 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정
- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
- 개념적 설계가 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스를 설계
- 관계형 DB라면 테이블을 설계하는 단계

### 물리적 설계
- 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정
- 물리적, 설계 단계에서는 다양한 DB 응용에 대해 처리 성능을 얻기 위해 DB 파일의 저장 구조 및 액세스 경로를 결정
- 저장 레코드의 형식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용해 데이터가 컴퓨터에 저장되는 방법을 묘사
- 물리적 설계 시 고려할 사항
    - 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간의 효율화 등

### 데이터 모델에 표시할 요소
- 구조(Structure)
    - 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
- 연산(Operation)
    - DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 DB를 조회하는 기본 도구
- 제약 조건(Constraint)
    - DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

### E-R 다이어그램
- E-R 모델의 기본 아이디어를 시작적으로 표현하기 위한 그림
```
그림으로 확인
```

### E-R(개체-관계) 모델
- 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터 첸(Peter Chen)에 의해 제안된 기본적인 구성 요소가 정립됨
- E-R 모델은 개체와 개체 간의 관계를 기본 요소로 이용해 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법으로 많이 사용되고 있음
- E-R 모델은 특정 DBMS를 고려한 것은 아님

### 튜플(Tuple)
- 릴레이션을 구성하는 각각의 행을 말함
- 파일 구조에서 레코드와 같은 의미
- 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응 수라고 함

### 속성(Attribute)
- DB를 구성하는 가장 논리적 단위
- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당 됨
- 속성은 개체의 특성을 기술함
- 속성의 수를 디그리(Degree) 또는 차수라고 함

### 도메인(Domain)
- 하나의 속성이 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
- 메인은 실제 속성 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용

### 후보키(Cardinality Key)
- 릴레이션을 구성하는 속성들 중 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, 유일성과 최소성을 모두 만족

### 릴레이션의 특징
- 한 릴레이션에 포함된 튜플들은 모두 상이
- 한 릴레이션에 포함된 튜플 사이에는 순서가 없음
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변화
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있음
- 속성은 더 이상 쪼갤 수 없는 원자값만을 저장

### 기본키(Primary Key)
- 후보키 중 특별히 선정된 키로 중복된 값과 NULL 값을 가질 수 없음
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성

### 대체키(Alternate Key)
- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미함
- 보조키라고도 함

### 슈퍼키(Super Key)
- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플등 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
- 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함

### 외래키(Foreign Key)
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미
- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 함

### 개체 무결성(Entity Integrity, 실체 무결성)
- 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정

### 도메인 무결성(Domain Integrity, 영역 무결성)
- 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정

### 참조 무결성(Referential Integrity)
- 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
- 외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야 함

### 사용자 정의 무결성(User-Defined Integrity)
- 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정

### 관계 대수
- RDBMS에서 원하는 정보와 그 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적 언어
- 관계 대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결과도 릴레이션임
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시
- 관계 대수에는 RDBMS에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음
- 순수 관계 연산자
    - Select, Project, Join, Division
- 일반 집합 연산자
    - UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)

### Select
- 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구해 새로운 릴레이션을 만드는 연산
- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 함
- 연산자의 기호는 그리스 문자 시그마를 사용함

### Join
- 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
- Join의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같음
- Join의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 같음
- 연산자의 기호는 나비모양을 사용함

### Division
- X ⊃ Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
- 연산자의 기호는 ÷ 를 사용
- 표기 형식
    - R [속성r ÷ 속성s] S

### Cartesian Product(교차곱)
- 두 릴레이션에 존재하는 모든 튜플들을 대응시켜 새로운 릴레이션을 만드는 연산
- 연산의 결과 차수는 두 릴레이션의 차수를 합한 것과 같고 튜플은 두 릴레이션의 튜플 수를 곱한 것과 같음

### 관계 해석
- 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 RDBMS를 위해 제안함
- 관계해석은 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용함
- 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님
- 기본적으로 관계해석과 관계대수는 RDBMS를 처리하는 기능과 능력면에서 동등하며, 관계대수로 표현한 식은 관계해석으로 표현할 수 있음
```
- 관계 해석 주요 기호
기호        |       구성 요소       |       설명        
∀                전칭 정량자           가능한 모든 튜플에 대하여(For All)
∃                존재 전량자           하나라도 일치하는 튜플이 있음(There Exists)
∨                  OR 연산
∧                  AND 연산
￢                 NOT 연산
```

### 정규화(Normalization)의 개념 및 목적
- 함수적 종속성 등의 종속성 이론을 이용해 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정
- 데이터 구조의 안전성 및 무결성을 유지
- 어떠한 릴레이션이라도 DB내에서 표현 가능하게 만듬
- 효과적인 검색 알고리즘을 생성할 수 있다.
- 데이터 중복을 배제해 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능
- 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임
- 자료 검색과 추출의 효율성을 추구

### 이상(Anomaly)의 개념 및 종류
- 정규화를 거치지 않으면 DB 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생하는데, 이를 이상(Anomaly)이라 하며, 삽입 이상, 삭제 이상, 갱신 이상이 있음.
- 삽입 이상(Insertion Anomaly)
    - 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
- 삭제 이상(Deletion Anomaly)
    - 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상
- 갱신 이상(Update Anomaly)
    - 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

### 1NF(제1정규형)
- 릴레이션에 속한 모든 도메인(Domain)이 원자값(Atomic Value)만으로 되어 있는 정규형. 즉 릴레이션의 모든 속성 값이 원자 값으로만 되어 있는 정규형

### 2NF(제2정규형)
- 릴레이션 R이 1NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족하는 정규형

### 함수적 종속(Functional Dependency)
- 데이터들이 어떤 기준값에 의해 종속되는 것을 의미
ex. <수강> 릴레이션이 (학번, 이름, 과목명)으로 되어 있을 때, '학번'이 결정되면 '과목명'에 상관없이 '학번'에는 항상 같은 '이름'이 대응된다. '학번'에 따라 '이름'이 결정될 때 '이름'을 '학번'에 함수 종속적이라고 하며 '학번'->'이름'과 같이 쓴다.

### 3NF(제3정규형)
- 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는 정규형

### 이행적 종속(Transitive Dependency) 관계
- A -> B이고 B -> C 일때 A -> C를 만족하는 관계를 의미

### BCNF(Boyce-Codd 정규형)
- 릴레이션 R에서 결정자가 모두 후보키(Candidate Key)인 정규형

### 4NF(제4정규형)
- 릴레이션R에 다치 종속 A->B가 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형

### 5NF(제5정규형)
- 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형

### 시스템 카탈로그(System Catalog)
- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 DB이다.
- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 함
- 시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함
- 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용해 내용을 검색해 볼 수 있음
- 카탈로그는 DBMS가 스스로 생성하고 유지함

### 정규화 과정
```
비정규 릴레이션 -> 1NF (도메인이 원자값)
1NF -> 2NF (부분적 함수 종속 제거)
2NF -> 3NF (이행적 함수 종속 제거)
3NF -> BCNF (결정자이면서 후보키가 아닌 것 제거)
BCNF -> 4NF (다치 종속 제거)
4NF -> 5NF (조인 종속성 이용)
```

### 반정규화(Denormalization)
- 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있음
- 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있음

### 트랜잭션(Transaction) 정의
- DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미
- 트랜잭션은 DB 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용됨
- 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용됨

### 트랜잭션의 상태
```
활동(Active)                    트랜잭션이 실행 중인 상태
실패(Failed)                    트랜잭션 실행 중 오류가 발생해 중단된 상태
철회(Aborted)                   트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
부분 완료(Partially Commited)   트랜잭션의 마지막 연산까지 완료했지만, Commit 연산이 실행되기 직전의 상태
완료(Committed)                 트랜잭션이 성공적으로 종료되어 Commit 연산까지 수행한 상태
```

### 인덱스(index)
- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성되는 데이터 구조
- 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있음
- 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공
- 인덱스를 통해 파일의 레코드에 대한 액세스를 빠르게 수행 가능
- 레코드의 삽입과 삭제가 수시로 일어나는 경우 인덱스의 개수를 최소로 하는 것이 효율
- 데이터 정의어(DDL)를 이용해 사용자가 생성, 변경, 제거 가능

### 트랜잭션의 특징

<table border="1">
    <tr>
        <td>Atomicity</td>
        <td>- 트랜잭션의 연산은 DB에 모두 반영되도록 Commit 되든지 전혀 반영되지 않도록 Rollback되어야 함 <br/>
        - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행 되어야 하며, 모두가 완벽히 수행되지 않고, 어느 하나라도 오류가 발생하면 트랜잭션 모두가 취소 되어야 함
        </td>
    </tr>
    <tr>
        <td>Consistency</td>
        <td>- 트랜잭션이 그 실행을 성공적으로 완료하며 언제나 일관성 있는 DB상태로 변환함 <br/>
        - 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 트랜잭션 수행 후의 상태가 같아야 함
        </td>
    </tr>
    <tr>
        <td>Isolation</td>
        <td>- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음 <br/>
        - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
        </td>
    </tr>
    <tr>
        <td>Durability</td>
        <td>
        - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함
        </td>
    </tr>
</table>

### CRUD 분석
- CRUD 분석은 DB 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것
- CRUD 분석으로 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있음
- CRUD 분석으로 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있음
- CRUD 분석을 통해 외부 프로세스 트랜잭션의 부학 집중되는 DB 채널을 파악하고 분산시킴으로써 연결 지연이나 타임아웃 오류를 방지

### 뷰(View)
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블
- 뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주됨
- 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 논리적 독립성을 제공할 수 있음
- 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신, 연산이 가능함
- 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
- 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 사용
- 독립적인 인덱스를 가질 수 없음
- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

### 파티션의 종류

<table border="1">
    <tr>
        <td>범위 분할(Range Partitioning)</td>
        <td>- 지정한 열의 값을 기준으로 범위를 지정하여 분할함 <br/>
        ex. 일별, 월별, 분기 등
        </td>
    </tr>
    <tr>
        <td>해시 분할(Hash Partitioing)</td>
        <td>- 해시 함수를 적용한 결과 값에 따라 데이터를 분할함 <br/>
        - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용 <br/>
        - 특정 데이터가 어디에 있는지 판단할 수 없음 <br/>
        - 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적임
        </td>
    </tr>
    <tr>
        <td>조합 분할(Composite Partitioning)</td>
        <td>- 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식 <br/>
        - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용함
        </td>
    </tr>
    <tr>
        <td>목록 분할(List Partitioning)</td>
        <td>
        - 지정한 열 값에 대한 목록을 만들어 이를 기준으로 분할함 <br/>
        ex. '국가'라는 열에 '한국', '미국', '일본'이 있는 경우 '미국'을 제외할 목적으로 '아시아'라는 목록을 만들어 분할
        </td>
    </tr>
    <tr>
        <td>라운드 로빈 분할(Round Robin Partitioning)</td>
        <td>
        - 레코드를 균일하게 분배하는 방식 <br/>
        - 각 레코드가 순차적으로 분배되며, 기본키가 필요없음
        </td>
    </tr>
</table>

### 분산 데이터베이스
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site)에 분산되어 있는 데이터베이스를 의미
- 분산 데이터베이스의 구성 요소
    - 분산 처리기, 분산 데이터베이스, 통신 네트워크

### 분산 데이터베이스의 목표
- 위치 투명성(Location Transparency)
    - 액세스하려는 DB의 실제 위치를 알 필요 없이 단지 DB의 논리적인 명칭만으로 액세스할 수 있음
- 중복 투명성(Replication Transparency)
    - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
- 병행 투명성(Concurrency Transparency)
    - 분산 DB와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- 장애 투명성(Failure Transparency)
    - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리

### 분산 DB의 장-단점

<table border="1">
    <tr>
        <th>장점</th>
        <th>단점</th>
    </tr>
    <tr>
        <td>- 자료의 공유성이 향상됨 <br/>
            - 분산 제어가 가능함 <br/>
            - 시스템 성능이 향상됨 <br/>
            - 효용성과 융통성이 높음 <br/>
            - 신뢰성 및 가용성이 높음 <br/>
            - 점진적 시스템 용량 확장이 용이함 <br/>
        </td>
        <td>- 데이터베이스 설계가 어려움 <br/>
            - 소프트웨어 개발 비용이 증가함 <br/>
            - 처리 비용이 증가함 <br/>
            - 잠재적 오류가 증가함 <br/>
        </td>
    </tr>
</table>

### 암호화(Encryption)
- 데이터를 보낼 때 송신자가 지정한 수신자 이외에느 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것
- 암호화(Encryption) 과정
    - 암호화되지 않은 평문을 정보 보호를 위해 암호문으롤 바꾸는 과정
- 복호화(Decryption) 과정
    - 암호문을 원래의 평문으로 바꾸는 과정

### 접근통제 기술
- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
- 접근통제는 데이터에 대해 다음과 같은 통제를 함으로써 자원의 불법적인 접근 및 파괴를 방지한다.
<table border="1">
    <tr>
        <td>임의 접근 통제(DAC:Discretionary Access Control)</td>
        <td>- 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
        </td>
    </tr>
    <tr>
        <td>강제 접근통제(MAC:Mandatory Access Control)</td>
        <td>- 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
        </td>
    </tr>
    <tr>
        <td>역할기반 접근통제(RBAC:Role Based Access Control)</td>
        <td>- 사용자의 역할에 따라 접근 권한을 부여하는 방식 
        </td>
    </tr>
</table>

### 벨 라파듈라 모델(Bell-LaPadula Model)
- 군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용
- 보안 취급자의 등급을 기준으로 읽기 권한과 쓰기 권한이 제한됨

### DAS(Direct Attached Storage)
- 서버와 저장장치를 전용 케이블로 직접 연결하는 방식으로, 일반 가정에서 컴퓨터에 외장하드를 연결하는 것이 여기에 해당
- 하드디스크와 같은데이터 저장장치를 호스트버스 어댑터에 직접 연결하는 방법
- 저장장치와 호스트 기기 사이에 네트워크 디바이스 없이 직접 연결하는 방식으로 구성

### SAN(Storage Area Network)
- DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장 장치를 연결하는 전용 네트워크를 별도로 구성하는 방식
- 광 채널(FC) 스위치를 이용해 네트워크를 구성함
- 광 채널 스위치는 서버나 저장장치를 광케이블로 연결하므로 처리 속도가 빠름

### DDL(Data Define Language, 데이터 정의어)
- SCHEMA, DOMAIN, TALBE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어
- DDL의 세가지 유형
<table border="1">
    <tr>
        <td>명령어</td>
        <td>기능
        </td>
    </tr>
    <tr>
        <td>CREATE</td>
        <td>- SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의함
        </td>
    </tr>
    <tr>
        <td>ALTER</td>
        <td>- TABLE에 대한 정의를 변경하는 데 사용
        </td>
    </tr>
    <tr>
        <td>DROP</td>
        <td>- SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함
        </td>
    </tr>
</table>

### DML(Data Manipulation Language, 데이터 조작어)
- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는 데 사용되는 언어
- DML의 네 가지 유형
<table border="1">
    <tr>
        <td>명령어</td>
        <td>기능
        </td>
    </tr>
    <tr>
        <td>SELECT</td>
        <td>- 테이블에서 조건에 맞는 튜플 검색
        </td>
    </tr>
    <tr>
        <td>INSERT</td>
        <td>- 테이블에 새로운 튜플 삽입
        </td>
    </tr>
    <tr>
        <td>UPDATE</td>
        <td>- 테이블에서 조건에 맞는 튜플의 내용을 변경
        </td>
    </tr>
    <tr>
        <td>DELETE</td>
        <td>- 테이블에서 조건에 맞는 튜플 삭제
        </td>
    </tr>
</table>

### DCL(Data Control Language, 데이터 제어어)
- 데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용되는 언어
- DCL(데이터 제어어)의 종류
<table border="1">
    <tr>
        <td>명령어</td>
        <td>기능
        </td>
    </tr>
    <tr>
        <td>COMMIT</td>
        <td>- 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, DB 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
        </td>
    </tr>
    <tr>
        <td>ROLLBACK</td>
        <td>- DB 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구
        </td>
    </tr>
    <tr>
        <td>GRANT</td>
        <td>- DB 사용자에게 권한을 부여
        </td>
    </tr>
    <tr>
        <td>REVOKE</td>
        <td>- DB 사용자의 사용 권한 취소
        </td>
    </tr>
</table>

- GRANT / REVOKE 형식
```
- GRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호];
- REVOKE 사용자등급 FROM 사용자_ID_리스트;
```

### CREATE TABLE
- 테이블을 정의하는 명령문
- 기본 테이블에 포함될 모든 속성에 대해 속성명과 그 속성의 데이터 타입, 기본값, NOT NULL 여부를 지정
- CHECK
    - 속성 값에 대한 제약 조건 정의

### ALTER TABLE
- 테이블에 대한 정의를 변경하는 명령문
- ADD
    - 새로운 속성(열)을 추가할때 사용
- ALTER
    - 특정 속성의 Default 값을 변경할 때 사용
- DROP COLUMN
    - 특정 속성을 삭제할 때 사용

### DROP
- 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령어
- CASCADE
    - 제거할 요소를 참조하는 다른 모든 개체를 함께 제거, 즉 주 테이블의 데이터를 제거 시 각 외래키와 관계를 맺고 있는 모든 데이터를 제거하는 참조 무결성 제약 조건을 설정하기 위해 사용
- RESTRICT
    - 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소

### 삭제문(DELETE FROM ~)
- 기본 테이블에 있는 튜플들 중 특정 튜플(행)을 삭제할 때 사용
- 모든 레코드를 삭제할 때는 WHERE절을 생략
- 모든 레코드를 삭제하더라도 테이블 구조는 남아 있기 때문에 디스크에서 테이블을 완전히 제거하는 DROP과는 다름

### DELETE, TRUNCATE
- TRUNCATE는 DELETE와 같이 테이블의 모든 데이터 삭제
- DROP과 달리 테이블 스키마는 제거되지 않고 유지
- DELETE에 비해 빠르게 제거가 가능
- DELETE는 ROLLBACK으로 살릴 수 있지만, TRUNCATE는 살릴 수 없음

### 갱신문(UPDATE ~ SET ~)
- 기본 테이블에 있는 튜플들 중 특정 튜플의 내용을 변경할 때 사용

### 기본 검색 및 조건 저장
- DISTINCT
    - 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색
- WHERE 절에는 검색할 조건 기술
- LIKE
    - 대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플만 검색
- 대표 문자
    - \* 또는 % : 모든 문자를 대표
- NULL 값의 사용
    - WHERE 주소 IS NULL
        - 주소가 NULL인, 즉 주소가 입력되지 않은 자료만 검색
    - WHERE 주소 IS NOT NULL
        - 주소가 NULL이 아닌, 즉 주소가 입력된 자료만 검색
- BETWEEN 연산자의 사용
    - WHERE 생일 BETWEEN #01/09/69# AND #10/22/73#
        - 생일이 '01/09/69'에서 '10/22/73' 사이인 자료만 검색

### 집합 연산자의 종류(통합 질의의 종류)
<table border="1">
    <tr>
        <td>집합 연산자</td>
        <td>설명</td>
        <td>집합 종류</td>
    </tr>
    <tr>
        <td>UNION</td>
        <td>- 두 SELECT문의 조회 결과를 통합하여 모두 출력 <br/>
            - 중복된 행은 한번만 출력
        </td>
        <td>합집합</td>
    </tr>
    <tr>
        <td>UNION ALL</td>
        <td>- 두 SELECT문의 조회 결과를 통합하여 모두 출력 <br/>
            - 중복된 행도 그대로 출력
        </td>
        <td>합집합</td>
    </tr>
    <tr>
        <td>INTERSECT</td>
        <td>- 두 SELECT문의 조회 결과 중 공통된 행만 출력함 
        </td>
        <td>교집합</td>
    </tr>
    <tr>
        <td>EXCEPT</td>
        <td>- 첫 번쨰 SELECT문의 조회 결과에서 두 번째 SELECT문의 조회 결과를 제외한 행을 출력
        </td>
        <td>차집합</td>
    </tr>
</table>

### 트리거(Trigger)
- DB 시스테메서 데이터의 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL
- 트리거는 DB에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 활용
- 트리거의 구문에는 DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류가 발생
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 세심한 주의가 필요

### IP 헤더(Header)의 구성
- Version Number : IP 프로토콜의 버전을 번호로 표시
- Header Length : 헤더의 길이를 32비트 워드 단위로 표현
- Service Type : 사용자에게 제공하는 서비스 품질에 관한 내용
- Packet Length : 헤더를 포함한 패킷의 전체 길이를 표현
- Identification : IP 프로토콜이 분할한 패킷에 동일한 고유번호를 부여해, 수신 호스트가 패킷을 병합할 수 있게 함
- DF : 패킷의 분할을 막는 역할을 수행
- MF : 전송될 패킷이 더 있는지 여부 표현
- Fragment Offset : 분할된 패킷이 분할 전에 위치했던 주소를 저장
- Time to Live : 네트워크에서 생존할 수 있는 시간으로, 목적지를 찾지 못하고 떠도는 패킷은 이 시간이 경과하면 자동으로 폐기됨
- Transport Protocol : 데이터 전송을 요구한 전송 계층의 프로토콜을 표현
- Header Checksum : 전송 과정에서 발생할 수 있는 헤더의 오류를 검출함
- Source Address : 송신 호스트의 주소를 표현함
- Destination Address : 수신 호스트의 주소를 표현함
- Options : 네트워크 관리, 보안 등의 특수 용도로 사용됨
- Padding : 각 구성의 전체 크기가 16비트 워드의 4배수가 되도록 조정하는 역할을 수행함

## 제 4과목 프로그래밍 언어 활용

### 배치 프로그램의 필수 요소
- 대용량 데이터
    - 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
- 자동화
    - 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함
- 견고성
    - 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함
- 안전성/신뢰성
    - 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
- 성능
    - 다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료되어야 함

### C/JAVA의 자료형
<table border="1">
    <tr>
        <td>종류</td>
        <td>C</td>
        <td>JAVA</td>
    </tr>
    <tr>
        <td>문자</td>
        <td>char(1Byte)
        </td>
        <td>char(1Byte)</td>
    </tr>
    <tr>
        <td>정수</td>
        <td>- int(4Byte) <br/>
            - long(8Byte)
        </td>
        <td>- int(4Byte) <br/>
            - long(8Byte)
        </td>
    </tr>
    <tr>
        <td>논리</td>
        <td>
        </td>
        <td>boolean(1Byte)</td>
    </tr>
</table>

### Python의 시퀀스 자료형의 종류
- 리스트(List)
    - 다양한 자료형의 값을 연속적으로 저장하며, 필요에 따라 개수를 늘리거나 줄일 수 있음
- 튜플(Tuple)
    - 리스트처럼 요소를 연속적으로 저장하지만, 요소의 추가, 삭제, 변경은 불가능함
- range
    - 연속된 숫자를 생성하는 것으로, 리스트, 반복문 등에서 많이 사용됨

### C언어의 구조체
- 자료의 종류가 다른 변수의 모임
- 예약어 struct를 이용해 정의

### C언어의 대표적 라이브러리
- stdio.h
    - 데이터의 입-출력에 사용되는 기능들을 제공
    - 주요 함수 : printf, scanf, fprintf, fscanf,fopen 등
- math.h
    - 수학 함수들을 제공
    - sqrt, pow, abs 등
- string.h
    - 문자열 처리에 사용되는 기능들을 제공
    - strlen, strcpy, strcmp 등
- stdlib.h
    - 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공
    - atoi, atof, srand, rand, malloc, free 등
- time.h
    - 시간 처리에 사용되는 기능들을 제공
    - time, clock 등

### 변수명 작성 규칙
- 영문자, 숫자, _ 를 사용할 수 있음
- 첫 글자는 영문자나 _로 시작해야 하며, 숫자는 올 수 없음
- 글자 수에 제한이 없음
- 공백이나 *,+,-,/ 등의 특수문자 사용 불가
- 대-소문자 구분
- 예약어는 사용불가
- 변수 선언 시 문장 끝에 반드시 세미콜론 필수

### 가비지 콜렉터(Garbage Collector)
- 선언만 하고 사용하지 않는 변수들이 점유한 메모리 공간을 강제로 해제하여 ㄷ른 프로그램들이 사용할 수 있도록 하는 것

### 연산자 우선순위
```
단항 연산자 > 산술 연산자 > 시프트 연산자 > 관계 연산자 > 비트 연산자 > 논리 연산자 > 조건 연산자 > 대입 연산자 > 순서 연산자
```

### C언어 포인터와 포인터 변수
- int *a;
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙임 ( a = &b;)

### 스크립트 언어의 종류
- 자바스크립트
    - 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어
- JSP
    - JAVA로 만들어진 서버용 스크립트로, 다양한 운영체제에서 사용 가능
- PHP
    - 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능
- Python
    - 귀도 반 로섬(Guido van Rossum)이 발표한 대화형 인터프리터 언어
    - 객체지향 기능을 지원하고 플랫폼에 독립적이며 문법이 간단해 배우기 쉬움
- Basic
    - 절차지향 기능을 지원하는 대화형 인터프리터 언어로, 초보자도 쉽게 사용할 수 있는 문법 구조를 갖음

### 쉡 스크립트
- 유닉스/리눅스 계열의 쉘(Shell)에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
- 쉘의 종류
    - Bash Shell, Bourne Shell, C Shell, Korn Shell 등
- 쉘 스크립트에서 사용되는 제어문
    - 선택형 : if, case
    - 반복문 : for, while, until

### 라이브러리
- 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체
- 표준 라이브러리
    - 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지로 구성됨
- 외부 라이브러리
    - 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용

### C언어의 stdlib.h
- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공
- 주요 함수
    - atoi, atof, srand, rand, malloc, free 등
    - malloc
        - 형식 : 포인터 변수 = malloc(크기);
        - 포인터 변수가 가리키는 메모리 위치에 지정된 크기만큼의 공간을 할당하되, 크기의 단위는 byte
        - 필요한 시점에, 필요한 만큼 메모리를 할당할 수 있으므로 동적 메모리 할당이라고 부름
        - malloc() 함수가 성공적으로 수행되면 메모리 주소를 반환하고, 실패하면 NULL을 반환
        - 힙 영역의 메모리를 할당하기 때문에, 사용 후 반드시 free() 함수를 통해 메모리를 해제해야 함

### UNIX 시스템 - 쉘(Shell)
- 사용자의 명령을 인식해 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
-시스템과 사용자 간에 인터페이스를 담당
- DOS의 COMMAND.COM과 같은 기능 수행
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리가 가능

### UNIX 시스템 - 커널(Kernel)
- Unix의 가장 핵심적인 부분
- 하드웨어를 보호(캡슐화)하고, 프로그램들과 하드웨어간의 인터페이스 역할을 담당
- 기능
    - 프로세스 관리, 기억장치 관리, 파일 관리, 입-출력 관리, 프로세스 간 통신, 데이터 전송 및 변환 등

### 기억장치 관리 전략
- 종류
    - 반입(Fetch) 전략, 배치(Placement)전략, 교체(Replacement) 전략
- 배치 전략의 종류
<table border="1">
    <tr>
        <td>최초 적합</td>
        <td>프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 첫 번째 분할 영역에 배치시키는 방법</td>
    </tr>
    <tr>
        <td>최적 적합</td>
        <td>프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
        </td>
    </tr>
    <tr>
        <td>최악 적합</td>
        <td>프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 크게 남기는 분할 영역에 배치시키는 방법
        </td>
</table>

### 페이지 교체 알고리즘 - FIFO
- 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래 있었던 페이지를 교체하는 기법

### 스래싱(Thrashing)
- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하됨
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 됨
- 스래싱 현상 방지 방법
    - 다중 프로그래밍 수준을 적정 수준으로 유지
    - 페이지 부재 빈도를 조절
    - 워킹 셋 유지
    - 부족한 자원 증설 및 일부 프로세스 중단
    - CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치 예상하여 운영

### 프로세스 상태 및 상태 전이
- 프로세스의 상태
    - 제출(Submit), 접수(Hold), 준비(Ready), 실행(Run), 대기(Wait, 보류, 블록), 종료(Teerminated, Exit)
    - 제출 : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
    - 접수 : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
    - 준비 : 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
    - 실행 : 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
    - 대기, 블록 : 프로세스에 입-출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입-출력 처리가 완료될 때까지 대기하고 있는 상태
    - 종료 : 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태
- 프로세스 상태 전이
    - Dispatch, Wake-Up, Spooling
    - Dispatch : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
    - Wake-up : 입-출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
    - Spooling : 입-출력장치의 공유 및 상대적으로 느린 입-출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입-출력할 데이터를 직접 입-출력장치에 보내지 않고 나중에 한꺼번에 입-출력하기 위해 디스크에 저장하는 과정



### 프로세스의 정의
- PCB를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
- 프로시저가 활동중인 것
- 비동기적 행위를 일으키는 주체
- 지정된 결과를 얻기 위한 일련의 계통적 동작
- 목적 또는 결과에 따라 발생되는 사건들의 과정
- 운영체제가 관리하는 실행 단위

### 스레드의 특징
- 실행 환경을 공유시켜 기억장소 및 자원의 낭비가 줄어듬
- 하나의 프로세스를 여러 개의 스레드로 생성해 병행성을 증진시킬 수 있음
- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있음
- 스레드는 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 함
- 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신
- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 함

### 사용자 수준 스레드와 커널 수준 스레드
- 사용자 수준 스레드
    - 사용자 수준의 라이브러리를 통해 구현된 스레드
    - 다수의 사용자 수준 스레드가 커널 수준 스레드 한 개에 다대일(n:1) 형태로 매핑됨
    - 독립적인 스케줄링이 가능하여 모든 운영체제에 적용할 수 있음
    - 스케줄링이나 동기화를 위해 커널을 호출하지 않으므로 오버헤드가 감소한다.
    - 라이브러리를 통해 스케줄링을 제어할 수 있어 유연한 스케줄링이 가능하다.
    - 스레드가 아닌 프로세스 단위로 CPU가 할당되어 스레드 단위의 다중 처리가 불가능하고, 하나의 스레드만 대기 상태가 되어도 프로세스 전체가 중단된다.
    - 스레드 간 보호에 커널의 보호 방법을 사용할 수 없고, 라이브러리에서 제공하는 보호 방법만 사용할 수 있다.
- 커널 수준 스레드
    - 커널이 생성 및 관리하는 스레드이다.
    - 커널이 각 스레드를 개별적으로 관리하므로 프로세스 내 스레드들의 독립적인 스케줄링 및 병행 수행이 가능하다.
    - 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.
    - 동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다.
    - 전체 프로세스와 스레드 정보를 유지하여 오버헤드가 커진다.

### SJF(Shortest Job First)
- 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법. 하지만, 실행중인 프로세스가 있다면 나중에 들어온 프로세스는 대기 상태를 가진다.

### CSMA/CD
- IEEE 802.3 LAN에서 사용되는 전송 매체 접속 제어(MAC) 방식

### HRN(Hightest Response-ratio Next)
- HRN 방식의 우선순위 계산식은 (대기시간 + 서비스 시간)/서비스 시간 의 결과가 큰 값이 우선순위
- 실행시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당
- 서비스 실행시간이 짧거나 대기시간이 긴 경우 우선순위가 높다

### UNIX의 주요 명령어
- fork
    - 새로운 프로세스를 생성 (하위 프로세스 호출, 프로세스 복제 명령)
- uname
    - 시스템의 이름과 버전, 네트워크 호스트명 등의 시스템 정보를 표시
- wait
    - fork 후 exec에 의해 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림
- chmod
    - 파일의 보호 모드를 설정해 파일의 사용 허가 지정
- ls
    - 현재 디렉토리 내의 파일 목록 확인
- cat
    - 파일 내용을 화면에 표시
- chown
    - 소유자 변경

### 인터넷 주소 체계 - IPv4
- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
- 숫자로 8비트씩 4부분, 총 32비트로 구성
- IP 주소는 네트워크 부분의 길이에 따라 A 클래스에서 E 클래스까지 총 5단계로 구성

### 인터넷 주소 체계 - IPv6
- IPv4의 주소 부족 문제를 해결하기 위해 개발된 것으로, 16비트씩 총 8부분, 총 128비트로 구성, 각 부분을 16진수로 표현하고 콜론(:)으로 구분
- IPv6 주소 체계
    - 유니캐스트(Unicast), 멀티캐스트(Multicast), 애니캐스트(Anycast)
- 주소의 확장성, 융통성, 연동성이 뛰어남
- 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이

### OSI 7 계층 - 데이터 링크 계층(Data Link Layer)
- 2개의 인접한 개방 시스템들 간 신뢰성 있고 효율적인 정보 전송 가능
- 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어 등을 수행
- 프로토콜
    - HDLC, LAPB, PPP, LLC 등

### OSI 7 계층 - 네트워크 계층(Network Layer)
- 개방 시스템들 간의 네트워크 연결을 관리(네트워크 연결을 설정, 유지, 해제)하고 데이터를 교환 및 중계함
- 경로 설정(Routing), 트래픽 제어, 패킷 정보 전송 등을 수행

### OSI 7 계층 - 전송 계층(Transport Layer)
- 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 함
- 전송 연결 설정, 데이터 전송, 연결 해제 기능, 주소 설정, 다중화(데이터의 분할과 재조립), 오류 제어, 흐름 제어 등을 수행

### TCP/IP 프로토콜 - MQTT
- 발행-구독 기반의 메시징 프로토콜로, IoT 환경에서 자중 사용됨

### TCP/IP 프로토콜 - TCP
- 신뢰성(안전성) 있는 연결형 서비스를 제공
- 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공
- 양방향 연결(Full Duplex Connection)형 서비스를 제공
- 스트림(Stream) 전송 기능을 제공

### TCP/IP 프로토콜 - UDP
- 데이터 전송 전 연결을 설정하지 않는 비연결형 서비스를 제공
- 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다
- 실시간 전송에 유리해, 신뢰성보다는 속도가 중요시 되는 네트워크에서 사용됨

### TCP/IP 프로토콜 - ARP
- 호스트의 IP 주소를 호스트와 연결된 네트워크 집속 장치의 물리적 주소(MAC Address)로 바꿈

### IP(Internet Protocol)
- OSI 7 계층의 네트워크 계층에 해당
- 데이터그램을 기반으로 하는 비연결형 서비스를 제공
- 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공
- 헤더의 길이는 최소 20Byte에서 최대 60Byte이다.
- IP 헤더에는 Version, Header Length, Total Packet Lenght, Header Checksum, Source IP Address, Destination Ip Address 등이 포함
- 에러 검사나 수신 확인 등을 수행하지 않아 신뢰성을 보장하지는 못하지만 전송에는 최선을 다하는 Best Effort 원칙을 따름

## 제 5 과목 - 정보시스템 구축 관리
### 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론
- 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리 적용

### 정보공학 방법론
- 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료(Data) 중심의 방법론
- 업무 영역 분석과 업무 시스템 설계 과정에 DB 설계를 위한 데이터 모델링으로 개체 관계도(ERD; Entity-Relationship Diagram)를 사용

### 컴포넌트 기반(CBD) 방법론
- 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 컴포넌트의 재사용이 가능해 시간과 노력을 절감 가능
- 새로운 기능을 추가하는 것이 아닌 간단해 확장성이 보장
- 유지 보수 비용을 최소화하고 생산성 및 품질을 향상
- 분석 단계에서 사용자 요구사항 정의서가 산출

### 소프트웨어 재사용의 이점
- 개발 시간과 비용 단축
- 소프트웨어 품질 향상
- 소프트웨어 개발의 생산성 향상
- 시스템 명세, 설계, 코드 등 문서 공유

### 소프트웨어 재사용 방법
- 합성 중심
    - 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법
- 생성 중심
    - 추상화 형태로 쓰여진 명세를 구체화해 프로그램을 만드는 방법

### 소프트웨어 재공학 이점
- 위험 부담 감소
- 개발 시간 단축
- 개발 비용 절감
- 시스템 명세의 오류 억제

### 소프트웨어 재공학의 주요 활동
- 분석
    - 기존 소프트웨어의 명세서를 확인해 소프트웨어의 동작을 이해하고, 재공학할 대상을 선정하는 활동
- 재구성
    - 기존 소프트웨어의 구조를 향상시키기 위해 코드를 재구성하는 활동
- 역공학
    - 기존 소프트웨어를 분석해 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어 내는 활동
- 이식
    - 기존 소프트웨어를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환하는 활동

### CASE(Computer Aided Software Engineering)
- 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용해 자동화하는 것
- CASE 도구를 통해 관리되는 공통 모듈을 사용할 수 있어 재사용성을 향상
- CASE 도구가 모듈 관리를 자동으로 수행하므로 유지 보수 간편
- 정형화된 구조 및 방법을 소프트웨어 개발에 적용해 생산성 및 품질 향상 구현

### CASE의 원천 기술
- 구조적 기법
- 프로토타이핑
- 자동 프로그래밍
- 정보 저장소
- 분산처리

### CASE의 주요 기능
- 소프트웨어 생명 주기 전 단계의 연결
- 다양한 소프트웨어 개발 모형 지원
- 모델들의 모순 검사 및 오류 검증
- 그래픽 지원
- 자료 흐름도 작성 등

### 비용 산정 기법 - LOC 기법
- 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정해 예측치를 구하고 이를 활용해 비용을 산정하는 기법
- 산정 공식
<table border="1">
    <tr>
        <td>노력(인월)</td>
        <td>- 개발 기간 x 투입 인원 <br/>
        - LOC / 1인당 월평균 생산 코드 라인 수
        </td>
    </tr>
    <tr>
        <td>개발 비용</td>
        <td>노력(인월) x 단위 비용(1인당 월 평균 인건비)
        </td>
    </tr>
    <tr>
        <td>개발 기간</td>
        <td>노력(인월) / 투입 인원
        </td>
    </tr>
    <tr>
        <td>생산성</td>
        <td>LOC / 노력(인월)
    </tr>
</table>

### 수학적 산정 기법의 종류
- COCOMO(COnstructive COst MOdel) 모형
- Putnam 모형
- 기능 점수(Function Point) 모형

### 비용 산정 기법 - Putnam 모형
- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해 주는 모형
- 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함

### 비용 산정 기법 - COCOMO
- 보헴이제안한 것으로, 원시 프로그램의 규모(LOC)에 의한 비용 산정 기법
- 비교적 작은 규모의 프로젝트 기록을 통계 분석해 얻은 결과를 반영한 모델
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)으로 나타냄

- COCOMO 모형의 종류
    - COCOMO는 비용 산정 단계 및 적용 변수의 구체화 정도에 따라 기본, 중간, 발전형으로 구분할 수 있음
    - 기본형 : 소프트웨어의 크기(생산 코드 라인 수)와 개발 유형만을 이용해 비용을 산정하는 모형
    - 중간형 : 기본형의 공식을 토대로 사용하나 제품, 컴퓨터, 개발 요원, 프로젝트의 특성을 이용해 비용을 산정하는 모형
    - 발전형 : 중간형을 보완하여 만들어진 방법으로 개발 공정별로 보다 자세하고 정확하게 산출해 비용을 산정하는 모형

### COCOMO의 소프트웨어 개발 유형
- 조직형(Organic Mode)
    - 기관 내부에서 개발된 중-소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형
- 반분리형(Semi-Detached Mode)
    - 조직형과 내장형의 중간형으로 트랜잭션 처리 시스템이나 운영체제, DB 관리 시스템 등의 30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형
- 내장형(Embedded Mode)
    - 내장형은 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형

### 자동화 추정 도구 - SLIM
- Rayleigh-Norden 곡선과 Putman 예측 모델을 기초로 해 개발된 자동화 추정 도구

### 기능 점수(FP) 모형 - 가중치 증대 요인
- 자료 입력(입력 양식)
- 정보 출력(출력 보고서)
- 명령어(사용자 질의 수)
- 데이터 파일
- 필요한 외부 루틴과의 인터페이스

### PERT(프로그램 평과 및 검토 기술; Program Evaluation and Review Technique)
- 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크 각 작업별로 낙관적인 경우, 가능성이 있는 경우, 비관적인 경우로 나누어 각 단계별 종료 시기를 결정하는 방법
- 과거에 경험이 없어 소요 기간 예측이 어려운 소프트웨어에서 사용
- 노드와 간선으로 구성되며, 원 노드에는 작업을 간선(화살표)에는 낙관치, 기대치, 비관치를 표시
- 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음
- 작업 예측치 : (비관치 + 4 x 기대치 + 낙관치) / 6
- 평방 편차 : [(비관치 - 낙관치) / 6]^2


### CPM(임계 경로 기법, Critical Path Method)
- 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 데 사용하는 기법
- 노드와 간선으로 구성된 네트워크로 노드는 작업을 간선은 작업 사이의 전후 의존 관계를 의미
- 원형 노드는 각 작업을 의미하며 각 작업 이름과 소요 기간을 표시하고, 박스 노드는 이정표를 의미하며 박스 노드 위에는 예상 완료 시간을 표시
- 간선을 나타내는 활살표의 흐름에 따라 각 작업이 진행되며, 전 작업이 완료된 후 다음 작업을 진행할 수 있음
- 각 작업의 순서와 의존 관계, 어느 작업이 동시에 수행될 수 있는지를 한눈에 볼 수 있음
- 병행 작업이 가능하도록 계획할 수 있으며, 이를 위한 자원 할당도 가능
- 임계 경로는 최장 경로를 의미
- 경영층의 과학적인 의사 결정을 지원
- 효과적인 프로젝트의 통제를 가능하게 해줌

### 간트 차트(Gantt Chart)
- 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용해 표시하는 프로젝트 일정표
- 수평 막대의 길이는 각 작업(Task)의 기간을 나타냄

### 소프트웨어 프로젝트 관리
- 주어진 기간 내 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동을 의미

### 위험 관리(Risk Analysis)
- 프로젝트 추진 과정에서 예상되는 각종 돌발 상황(위험)을 미리 예상하고 이에 대한 적절한 대책을 수립하는 일련의 활동을 의미
- 위험은 불확실성과 손실을 내재하고 있는데, 위험 관리는 이러한 위험의 불확실성을 감소시키고 손실에 대비하는 작업
- 위험을 식별한 후 발생 확률을 산정하고, 그 영향을 추산하여 해당 위험에 대비하는 비상 계획을 마련한다.
- 위험 관리의 절차는 위험 식별, 위험 분석 및 평가, 위험 관리 계획, 위험 감시 및 조치 순이다.

### ISO/IEC 12207
- 기본 생명 주기 프로세스
    - 획득, 공급, 개발, 운영, 유지 보수 프로세스
- 지원 생명 주기 프로세스
    - 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
- 조직 생명 주기 프로스세
    - 관리, 기반 구조, 훈련, 개선 프로세스

### CMMI의 소프트웨어 프로세스 성숙도 5단계
- 초기
- 관리
- 정의
- 정략적 관리
- 최적화

### SPICE(소프트웨어 처리 개선 및 능력 평가 기준)
- 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

### SPICE의 프로세스 수행 능력 단계
- Level 0 - 불완전
- Level 1 - 수행
- Level 2 - 관리
- Level 3 - 확립
- Level 4 - 예측
- Level 5 - 최적화

### 소프트웨어 개발 방법론 테일러링
- 프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업
- 관리적 측면
    - 최단기간에 안정적인 프로젝트 진행을 위해 사전 위험을 식별하고 제거하는 작업
- 기술적 측면
    - 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 찾아가는 작업

### 소프트웨어 개발 방법론 테일러링 고려사항
- 내부적 기준
    - 목표 환경 : 시스템의 개발 환경과 유형
    - 요구 사항 : 개발, 운영, 유지보수 등
    - 프로젝트 규모 : 비용, 인력, 기간 등
    - 보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능력 등
- 외부적 기준
    - 법적 제약사항 : 프로젝트별로 적용될 IT Compliance
    - 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준

### 소프트웨어 개발 프레임워크
- 프레임워크
    - 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화해 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템
- 선행 사업자의 기술에 의존하지 않은 표준화된 개발 기반으로 인해 사업자 종속성이 해소
- 개발해야 할 애플리케이션의 일부분이 이미 내장된 클래스 라이브러리로 구현되어 있어 개발자는 이미 존재하는 부분을 확장 및 이용하는 것으로 소프트웨어를 개발할 수 있음
- 프레임워크의 특성
    - 모듈화, 재사용성, 확장성, 제어의 역흐름
- 주요 기능
    - 예외 처리, 트랜잭션 처리, 메모리 공유, 데이터 소스 관리, 서비스 관리 ,쿼리 서비스, 로깅 서비스, 사용자 인증 서비스

### SDN(Software Defined Networking)
- 네트워크를 컴퓨터처럼 모델링해 여러 사용자가 각각의 소프트웨어들로 네트워킹을 가상화하여 제어하고 관리하는 네트워크
- 네트워크 비용 및 복잡성을 해결할 수 있는 기술로 간주되어 기존 네트워킹 기술의 폐쇄형 하드웨어 및 소프트웨어 기술을 개방형으로 변화시키는 미래 인터넷 기술로 급부상
- 네트워크를 제어부, 데이터 전달부로 분리해 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술
- 기존의 라우터, 스위치 등과 같이 하드웨어에 의존하는 네트워크 체계에서 안전성, 속도, 보안 등을 소프트웨어로 제어, 관리하기 위해 개발됨
- 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하고, 기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통해 인터넷상에서 발생하는 문제를 처리할 수 있음

### SDS(Software-Defined Storage)
- 물리적인 데이터 스토리지를 가상화해 여러 스토리지를 하나처럼 관리하거나, 하나의 스토리지를 여러 스토리지로 나눠 사용할 수 있는 기술

### SDDC(Software Defined Data Center)
- 데이터 센터의 모든 자원을 가상화해 인력의 개입없이 소프트웨어 조작만으로 관리 및 제어되는 데이터 센터

### 메시 네트워크
- 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수 목적을 위한 네트워크
- 수십에서 수천 개의 디바이스를 그물망과 같이 유기적으로 연결 해 모든 구간을 동일한 무선망처럼 구성해 사용자가 안정적인 네트워크를 사용할 수 있게 함

### 피코넷(PICONET)
- 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB(Ultra Wide Band) 통신 기술을 사용해 통신망을 형성하는 무선 네트워크 기술

### 클라우드 기반 HSM(Cloud Based hardware Security Module)
- 클라우드를 기반으로 암호화 키의 생성-저장-처리 등의 작업을 수행하는 보안기기를 가리키는 용어
- 암호화 키 생성이 하드웨어적으로 구현되기 때문에 소프트웨어적으로 구현된 기술이 가지는 보안 취약점을 무시할 수 있음
- 클라우드에 인증서를 저장하므로 스마트폰과 같은 개별 기기에 인증서를 저장할 필요가 없음
- 대표적인 클라우드 HSM 서비스 제공자에는 구글이 있음

### 파스-타(PaaS-TA)
- 소프트웨어 개발 환경을 제공하기 위해 개발한 개방형 클라우드 컴퓨팅 플랫폼
- 국내 IT 서비스 경쟁력 강화를 목표로, 인프라 제어 및 관리 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성되어 있음

### 징(Zing)
- 10cm 이내 거리에서 3.5Gbps 속도의 데이터 전송이 가능한 초고속 근접무선통신(NFC)이다.
- 휴대용 스마트 기기, 노트북, 쇼핑몰-거리 등의 광고나 키오스크에 접목해 사용가능

### 광대역 통합망(BcN; Broadband Convergence Network)
- 개별적인 망들이 갖고 있는 한계점을 극복해 음성, 데이터, 유선, 무선, 통신, 방송 등의 다양한 멀티미디어 서비스를 장소와 시간에 관계없이 일정한 품질로 안전하게 이용할 수 있는 차세대 네트워크

### 마린내비(Marine Navi)
- 소형 선박의 충돌사고 예방을 위해 KT에서 만든 선박 안전 솔루션을, GPS 기반 선박 자동식별 장치(AIS)를 통해 선박의 속도와 위치를 파악하고, 주변 선박과의 거리, 충돌 가능성 등을 인공지능(AI)을 통해 분석하여 전자해도(ENC)로 제공함

### 셀룰러-차량-사물통신(C-V2X; Cellular Vehicle To Everything)
- 이동 통신망을 이용해 차량 대 차량, 차량 대 보행자, 차량 대 인프라 간에 정보를 공유하는 기술로, 3GPP에서 제정한 기술 표준 중 하나

### SSO(Single Sign On)
- 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템

### 스마트 그리드(Smart Grid)
- 정보 기술을 전력에 접목해 효율성을 높인 시스템
- 전력선을 기반으로 모든 통신, 정보, 관련 애플리케이션 인프라를 하나의 시스템으로 통합하여 관리함으로써 효율적인 에너지 관리 가능

### WDM(Wavelength Division Mulitiplexing)
- 광섬유를 이용한 통신 기술의 하나로, 파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성질을 이용해 서로 다른 복수의 신호를 보냄으로써 여러 대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 기술

### 버스형(Bus)
- 한 개의 통신 회선에 여러 대의 단말장치가 연결된 형태

### VLAN(Virtual Local Area Network)
- LAN의 물리적인 배치와 상관없이 논리적으로 분리하는 기술로, 접속된 장비들의 성능 및 보안성을 향상시킬 수 있음

### WPA(Wi-Fi Protected Access)
- Wi-Fi에서 제정한 무선 랜(WLAN) 인증 및 암호화 관련 표준

### CSMA/CA
- 무선 랜에서 데이터 전송 시 매체가 비어있음을 확인한 뒤 충돌을 피하기 위해 일정한 시간을 기다린 후 데이터를 전송하는 방법
- 회선을 사용하지 않는 경우에도 확인 신호를 전송해 동시 전송에 의한 충돌을 예방

### LAN의 표준 규격 - 802.11e
- 802.11의 부가 기능 표준으로, QoS 기능이 지원되도록 하기 위해 매체 접근 제어(MAC) 계층에 해당하는 부분을 수정

### RIP(Routing Information Protocol)
- IGP에 속하는 라우팅 프로토콜로, 거리 벡터 라우팅 프로토콜이라고도 불림
- 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용
- 최대 홉(Hop) 수를 15로 제한

### OSPF(Open Shortest Path First Protocol)
- RIP의 단점을 해결해 새로운 기능을 지원하는 라우팅 프로토콜
- 최단 경로 탐색에 다익스트라 알고리즘을 사용
- 네트워크 변화에 신속하게 대처할 수 있고, 멀티캐스팅을 지원

### 흐름 제어 - 정지-대기(Stop-and-Wait)
- 수신 측의 확인 신호(ACK)를 받은 후 다음 패킷을 전송하는 방식
- 한 번에 하나의 패킷만을 전송 가능

### 도커(Docker)
- 컨테이너 기술을 자동화하여 쉽게 사용할 수 있게 하는 오픈소스 프로젝트
- 소프트웨어 컨테이너 안에 응용 프로그램들을 배치시키는 일을 자동화 해주는 역할 수행

### 스크래피(Scrapy)
- Python 기반의 웹 크롤링 프레임워크로, 코드 재사용성을 높이는 데 도움이 되며, 대규모의 크롤링 프로젝트에 적합

### 텐서플로(TensorFlow)
- 구글의 구글 브레인 팀이 만든, 다양한 작업에 대해 데이터 흐름 프로그래밍을 위한 오픈소스 소프트웨어 라이브러리

### 서비스 지향 아키텍처(SOA) 기반 애플리케이션 구성 계층
- 표현 계층
- 업무 프로세스 계층
- 서비스 중간 계층
- 애플리케이션 계층
- 데이터 저장 계층

### 매시업(Massup)
- 웹에서 제공하는 정보 및 서비스를 이용해 새로운 소프트웨어나 서비스, DB등을 만드느 기술

### 디지털 트윈
- 현실 속의 사물을 소프트웨어로 가상화한 모델
- 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있음

### 서비스형 블록체인(BaaS)
- 블록체인 앱의 개발 환경을 클라우드 기반으로 제공하는 서비스
- 블록체인 네트워크에 노드의 추가 및 제거가 용이

### TCP 래퍼(Wrapper)
- 외부 컴퓨터의 접속 인가 여부를 점검해 접속을 허용 및 거부하는 보안용 도구
- 네트워크에 접속하면 로그인한 다른 컴퓨터 사용자의 ID 및 로그를 조회하여 악용이 가능한 데, 이것을 방지하기 위한 방화벽 역할을 수행

### DPI(Deep Packet Inspection)
- OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악해 침입 시도, 해킹 등을 탐지하고, 트래픽을 조정하기 위한 패킷 분석 기술

### 허니팟(Honeypot)
- 비정상적인 접근의 탐지를 위해 의도적으로 설치해 둔 시스템
- 침입자르 속여 실제 공격당하는 것처럼 보여줌으로써 추적 및 공격기법에 대한 정보 수집

### OWASP(오픈 웹 애플리케이션 보안 프로젝트)
- 웹 정보 노출이나 악성 코드, 스크립트, 보안이 취약한 부분을 연구하는 비영리 단체

### 고가용성 솔루션(HACMP)
- 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘을 의미
- 각 시스템 간 공유 디스크를 중심으로 클러스터링으로 엮어 다수의 시스템을 동시에 연결 가능

### 앤 스크린(N-Screen)
- N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스를 말함
- PC, TV, 휴대폰에서 동일한 콘텐츠를 끊김 없이 이용할 수 있음

### Secure OS
- 기존의 운영체제에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식해 외부의 침입으로부터 시스템 자원을 보호하는 운영체제를 의미
- Secure OS의 보안 기능
    - 식별 및 인증, 임의적/강제적 접근통제, 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소 등

### 하둡(Hadoop)
- 오픈 소스를 기반으로 하는 분산 컴퓨팅 플랫폼
- 하둡과 RDBMS 간 대용량 데이터를 전송할 때 스쿱(Sqoop)이라는 도구 이용

### 맵리듀스(MapReduce)
- 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델
- Google에 의해 고안되었으며, 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법으로 많이 사용되고 있음

### 타조(Tajo)
- 오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트
- 대규모 데이터 처리와 실시간 상호 분석에 모두 사용 가능

### 데이터 마이닝
- 데이터 웨어하우스에 저장된 대량의 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법

### OLAP(Online Analytical Processing)
- 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석해 의사결정에 활용하는 방식
- OLAP 연산
    - Roll-up, Drill-down, Drill-through, Drill-across, Pivoting, Slicing, Dicing

### 회복(recovery)
- 트랜잭션들을 수행하는 도중 장애가 발생해 DB가 손상되었을 때 손상되기 이전의 정상 상태로 복수하는 작업

### 즉각 갱신 기법(Immediate Update)
- 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 DB에 반영하는 방법
- 장애가 발생해 회복 작업할 경우를 대비해 갱신된 내용들은 Log에 보관

### 로킹 단위(Locking Granularity)
- 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미
- DB, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아지고, 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아짐

### 타임 스탬프 순서
- 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중 가장 보편적인 방법
- 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작 하기 전에 시간표(Time Stamp)를 부옇여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
- 교착 상태가 발생하지 않는다.

### 교착상태 발생의 필요 충분 조건 4가지
- 상호 배제(Mutual Exclusion) : 한 번에 한개의 프로세스만이 공유자원을 사용할 수 있어야 함
- 점유와 대기(Hold and Wait) : 최소한 하나의 자원을 점유하고 있으며 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
- 비선점(Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없어야 함
- 환형 대기(Circular Wait) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하며 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함

### 회피 기법(Avoidance)
- 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해 나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용
- 은행원 알고리즘
    - E. J. Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법

### Seven Touchpoints
- 소프트웨어 보안의 모범사례를 SDLC에 통합한 방법론
- 설계 및 개발 과정의 모든 산출물에 대해 위험 분석 및 테스트를 수행

### 보안 3대 요소
- 기밀성
    - 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용되며, 정보가 전송 중 노출되더라도 데이터를 읽을 수 없음
- 무결성
    - 시스템 내의 정보는 오직 인가된 사용자만 수행 가능
- 가용성
    - 인가된 사용자는 언제라도 사용할 수 있음
- + 인증
    - 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위
    - 지식 기반 인증
        - 사용자가 기억하고 있는 정보 기반
        - 고정된 패스워드, 패스 프레이즈, 아이핀
    - 소유 기반 인증
        - 사용자가 소유하고 있는 것을 기반
        - 신분증, 메모리 카드(토큰), 스마트 카드, OTP
    - 생체 기반 인증
        - 사용자의 고유한 생체 정보 기반
        - 지문, 홍채/망막, 얼굴, 음성, 정맥 등
    - 행위 기반 인증
        - 사용자의 행동 정보
        - 서명, 동작, 음성
    - 위치 기반 인증
        - 인증을 시도하는 위치의 적절성
        - 콜백, GPS나 IP 주소를 이용한 위치 기반 인증
- + 부인 방지
    - 데이터를 송-수신한 자가 송-수신 사실을 부인할 수 없도록 송-수신 증거를 제공

### 세션 하이재킹(Session Hijacking)
- 서버에 접속하고 있는 클라이언트들의 세션 정보를 가로채는 공격기법으로, 세션 가로채기라고도 함
- 정상적인 연결을 RST(Reset) 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결하는 방식
- 공격자는 서버와 상호 간의 동기화된 시퀀스 번호를 이용해 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 됨
- 탐지 방법에는 비동기화 상태 탐지, ACK Storm 탐지, 패킷의 유실 탐지, 예상치 못한 접속의 리셋 탐지가 있음

### 피기백 공격(Piggyback Attack)
- 시스템의 올바른 인증 절차나 보안 프로그램에 편승하는 공격 방법으로, 권한 있는 사람이 열고 지나간 문틈을 파고들어 가는것에 빗 댐

### 입력 데이터 검증 및 표현의 보안 약점
- SQL 삽입(SQL Injection)
    - 웹 응용 프로그램에 SQL을 삽입하여 내부 DB 서버의 데이터를 유출 및 변조하고, 관리자 인증을 우회하는 보안 약점
- 경로 조작 및 자원 삽입
    - 데이터 입출력 경로를 조작해 서버 자원을 수정-삭제할 수 있는 보안 약점
- 크로스사이트 스크립팅
    - 웹 페이지에 악의적인 스크립트를 삽입해 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
- 메모리 버퍼 오버플로
    - 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 때 발생하는 보안 약점
- 운영체제 명령어 삽입
    - 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
- 위험한 형식 파일 업로드
    - 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
- 신뢰되지 않는 URL 주소로 자동접속 연결
    - 입력 값으로 사이트 주소를 받는 경우 이를 조작해 방문자를 피싱 사이트로 유도하는 보안 약점

### 하드코드된 비밀번호
- 소스코드 유출 시 내부에 하드코드된 패스워드를 이용해 관리자 권한 탈취 가능
- 하드코드
    - 데이터를 코드 내부에 직접 입력해 프로그래밍하는 방식

### 스택 가드(Stack Guard)
- 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우 오버플로우 상태로 판단해 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막는 기술

### 접근 지정자(접근 제어자)
- 프로그래밍 언어에서 특정 개체를 선언할 때 외부로부터의 접근을 제한하기 위해 사용되는 예약어
- 종류
    - Public, Protected, Default, Private

### 개인키 암호화 기법
- 동일한 키로 데이터를 암호화하고 복호화한다
- 알고리즘이 단순화하므로 암호화/복호화 속도가 빠름

### 개인키 암호화 기법의 종류
- 블록 암호화 방식
    - 한 번에 하나의 데이터 블록을 암호화하는 방식
    - DES, SEED, AES, ARIA, IDEA 등
- 스트링 암호화 방식
    - 평문과 동일한 길이의 스트림을 생성해 비트/바이트/워드 단위로 암호화하는 방식
    - LFSR, RC4 등

### 해시(Hash)
- 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
- 복호화가 거의 불가능한 일방향 함수에 해당
- 해시 함수의 종류
    - SHA 시리즈, MD4, MD5, N-NASH, SNEFRU 등

### 공개키 암호화 기법
- 데이터를 암호화할 때 사용하는 공개키는 DB 사용자에게 공개하고, 복호화할 떄의 비밀키는 관리자가 비밀리에 관리
- 공개키 암호화 기법에서 암호화 대상이 n개일 때 사용되는 키의 개수는 2n이다.
- 공개키 암호화 기법은 비대칭 암호 기법이라고도 하며, 개표적으로는 RSA(Rivest Shamir Adleman) 기법ㅇ 있음
- 키의 분배가 용이하고, 관리해야 할 키의 개수가 적음

### 양방향 알고리즘 종류
- DES(Data ncryption Standard)
    - 1975년 미국 NBS에서 발표한 64비트의 개인키 암호화 알고리즘
    - 블록 크기는 64비트이며, 키 길이는 56비트이다.
- AES(Advanced Encryption Standard)
    - DES에 한계를 느낀 미국 표준 기술 연구소(NIST)가 2001년 발표한 개인키 암호화 알고리즘
    - 블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류한다.
- RSA(Rivest Shamir Adleman)
    - 큰 숫자를 소인수분해 하기 어렵다는 것이 기반해 만들어진 공개키 암호화 알고리즘
- SEED 
    - 1999년 한국인터넷진흥원(KISA)에서 개발한 블록 암호화 알고리즘
    - 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류
- ARIA(Academy, Research Institute, Agency)
    - 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘
    - 블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류

### 솔트(Salt)
- 암호화를 수행하기에 앞서 원문에 무작위의 값을 덧붙이는 과정
- 솔트를 사용하면 패스워드에 대해 암호화를 수행하더라도 서로 다른 결과가 나타나게 되어 더 안전하게 암호화된 데이터를 관리할 수 있게 됨

### 죽음의 핑(Ping of Death)
- Ping 명령을 전송할 때 ICMP 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송해 공격 대상의 네트워크를 마비시키는 서비스 거부 공격

### SMURFING(스머핑)
- IP나 ICMP의 특성을 악용해 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법

### DDoS 공격
- 여러 곳에 분산된 공격 시점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것
- 분산 서비스 공격용 툴의 종류
    - Trin00, TFN(Tribe Flooding Network), TFN2K, Stacheldraht 등

### 피싱(Phishing)
- 개인 정보와 낚시의 합성어로, 이메일이나 메신저 등을 통해 공기관이나 금융 기관을 사칭해 개인 정보를 빼내는 기법

### Ping Flood
- 특정 사이트에 매우 많은 ICMP 메시지를 보내 이에 대한 응답(Respond)으로 시스템 자원을 모두 사용하게 해 시스템이 정상적으로 동작하지 못하도록 하는 공격 방법

### 스위치 재밍(SWitch Jamming)
- 위조된 매체 접근 제어(MAC) 주소를 지속해서 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브처럼 작동하게 하는 공격

### Parsing(파싱)
- 주어진 문장이 정의된 문법 구조에 따라 완전한 문장으로 사용될 수 있는가를 확인하는 작업

### LAN Tapping
- LAN 회선 중간에서 전기 신호를 도청하는 행위

### 블루투스 관련 공격
- 블루버그
    - 블루투스 장비 사이의 취약한 연결 관리를 악용한 공격으로, 휴대폰을 원격 조정하거나 통화를 감청할 수 있음
- 블루스나프
    - 블루투스의 취약점을 활용해 장비의 파일에 접근하는 공격으로, 인증없이 간편하게 정보를 교환할 수 있는 OPP(Object Push Profile)를 사용해 정보를 열람
- 블루프린팅
    - 공격 대상이 될 블루투스 장비를 검색하는 활동
- 블루재킹
    - 블루투스를 이용해 스팸처럼 메시지를 익명으로 퍼뜨리는 공격

### 웜
- 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높임으로써 결국 시스템을 다운시키는 바이러스의 일종

### Rogue Ware(로그 웨어)
- 사용자를 속여 악성코드를 설치하도록 유도하는 소프트웨어로, 주로 바이러스에 감염되었다며 백신 소프트웨어처럼 보이는 악성코드를 설치하도록 유도함

### Adware(애드웨어)
- 소프트웨어 자체에 광고를 포함하여 이를 보는 대가로 무료로 사용하는 소프트웨어

### Reflection Attack(반사 공격)
- 송신자가 생성한 메시지를 가로채 접근 권한을 얻는 형태의 공격 기법

### 키로거 공격
- 컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드, 계좌번호, 카드번호 등과 같은 개인의 중요한 정보를 몰래 빼가는 해킹 공격

### 랜섬웨어(RansomWare)
- 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램으로, 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구

### 백도어
- 시스템 설계자가 서비스 기술자나 유지보수 프로그램 작성자의 액세스 편의를 위해 시스템 보안을 제거해 만들어놓은 비밀 통로로, 컴퓨터 범죄에 악용되기도 함
- 백도어 탐지 방법
    - 무결성 검사, 열린 포트 확인, 로그 분석, setUID 파일 검사 등

### 인증
- 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인해 접근 권한을 검증하는 보안 절차
- 인증의 유형
    - 지식 기반 인증 : 고정된 패스워드, 아이핀 등
    - 소유 기반 인증 : 신분증, 토큰, 스마트카드 등
    - 행위 기반 인증 : 서명, 움직임, 음성 등

### 관리적/물리적/기술적 보안
- 관리적 보안
    - 정보보호 정책, 정보보호 조직, 정보자산 분류, 정보보호 고육 및 훈련, 인적 보안, 업무 연속성 관리 등의 정의
- 물리적 보안
    - 건물 및 사무실 출입 통제 지침, 전산실 관리 지침, 정보 시스템 보호 설치 및 관리지침, 재해 복구 센터 운영 등의 정의
- 기술적 보안
    - 사용자 인증, 접근 제어, PC, 서버, 네트워크, 응용 프로그램, 데이터(DB) 등의 보안지침 정의

### 커널 로그의 종류
- wtmp
    - 성공한 로그인/로그아웃과 시스템의 시작/종료시간에 대한 로그
- utmp  
    - 현재 로그인 한 사용자의 상태에 대한 로그
- btmp
    - 실패한 로그인에 대한 로그
- lastlog
    - 마지막으로 성공한 로그인에 대한 로그

### 침입 탐지 시스템(IDS)
- 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
- 방화벽과 같은 침입 차단 시스템만으로는 내부 사용자의 불법적인 행동과 외부 해킹에 100% 완벽하게 대처할 수 없다.
- 문제가 발생한 경우 모든 내-외부 정보의 흐름을 실시간으로 차단하기 위해 해커 침입 패턴에 대한 추적과 유해 정보 감시가 필요하다.
- 오용 탐지(Misuse Detection)
    - 미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌
- 이상 탐지(Anomaly Detection)
    - 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
- 침입 탐지 시스템의 위치
    - 패킷이 라우터로 들어오기 전 : 네트워크에 시도되는 모든 공격을 탐지
    - 라우터 뒤 : 라우터에 의해 패킷 필터링을 통과한 공격을 탐지할 수 있음
    - 내부 네트워크 : 내부에서 내부 네트워크의 해킹 공격을 탐지할 수 있음
    - DMZ : DMZ는 외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크로, 강력한 외부 공격이나 내부 공격으로부터 중요 데이터를 보호하거나 서버의 서비스 중단을 방지할 수 있음

### VPN(Virtual Private Network)
- 가상 사설 네트워크로서 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용해 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션

### SSH(시큐어 쉘)
- 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램
- 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신 가능
- 키(key)를 이용한 인증 방법을 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 함
- 기본적으로는 22번 포트를 사용

### 네트워크 장비
- NIC
    - 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로, 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함
- 허브(Hub)
    - 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함함
- 리피터(Repeater)
    - 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행
- 브리지(Bridge)
    - LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(Segment)을 연결하는 기능을 수행함
- 브라우터
    - 브리지와 라우터의 기능을 모두 갖추고 있는 네트워크 장비
- 스위치
    - 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
- 라우터
    - 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행함
- 게이트웨이
    - 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행함

### 통신망 알고리즘
- Diffie-Hellman Algorithm
    - 이산대수의 복잡성을 활용해 두 사용자가 사전에 어떠한 비밀 교환 없이도 비밀 키 교환을 가능하게 하는 알고리즘
- Hash Algorithm
    - 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 알고리즘
- DSA(Digital Signature Algorithm)
    - 미국 표준 기술 연구소(NIST)에서 표준안으로 개발한 공개 키 기반의 알고리즘으로, 디지털 서명 기술을 제공하기 위해 이산대수의 복잡성을 활용함

### NTFS 파일 시스템
- NTFS는 Windows 전용 파일 시스템으로, 다른 운영체제에서는 사용할 수 없다.
- FAT, FAT32에 비해 성능, 보안, 안전성 면에서 뛰어난 고급 기능을 제공하며, 시스템 리소스를 최소화 할 수 있다.
- 대용량 볼륨에 효율적이다.
- 파일 및 폴더에 대한 액세스 제어를 유지하고 '표준 사용자' 계정을 지원한다.
- 자동 압축 기능을 제공하며 저용량의 볼륨도 효율적으로 사용할 수 있다.
- 클러스터의 크기로 인해 저용량 볼륨에서는 FAT 또는 FAT32에 비해 비교적 속도가 느리다.

