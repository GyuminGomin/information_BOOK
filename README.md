# 정처기 필수 암기 363선

## 제 1 과목 소프트웨어 설계

### 소프트웨어 공학
- 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문
- 소프트웨어의 개발, 운용, 유지보수에 대한 체계적인 접근 방법
- 소프트웨어의 품질과 생산성을 향상시킬 목적
- 경제적인 비용을 들여 신뢰성 높은 소프트웨어를 개발하기 위해 공학적 원리를 정립하고 이를 적용하는 것

### 소프트웨어 공학의 기본 원칙
- 현대적인 프로그래밍 기술을 계속적으로 적용해야 함
- 개발된 소프트웨어 품질이 유지되도록 지속적으로 검증해야 함
- 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록 유지

### 폭포수 유형 (Waterfall Model)
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저히 검토해 승인 과정을 거친 후 다음 단계 진행하는 개발 방법론
- 보헴(Boehm)이 제시한 고전적 생명 주기 모형
- 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형
- 개발 과정에서 발생하는 요구사항 반영 어려움

### 나선형 모형 (Sprial Model, 점진적모형)
- 보헴이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 나선을 따라 돌듯 여러 번의 소프트웨어 개발 과정을 거쳐 점전직으로 완벽한 최종 소프트웨어를 개발하는 것
- `계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가` 과정이 반복적으로 수행됨

### 애자일 모형(Agile Model)
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하며 개발 과정을 진행
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
    - 스크럼(Scrum)
    - XP(eXtreme Programming)
    - 칸반(Kanban)
    - 린(Lean)
    - 크리스탈(Crystal)
    - ASD(Adaptive Software Development)
    - 기능 중심 개발(FDD; Feature Driven Development)
    - DSDM(Dynamic System Development Method)
    - DAD(Disciplined Agile Delivery)

### 애자일 개발 4가지 핵심 가치
- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 더 가치를 둠
- 계약 협상보다는 고객과 협업에 더 가치를 둠
- 계획을 따르기 보단 변화에 반응하는 것이 더 가치 있음

### 스크럼(Scrum) 기법의 주요 용어
- 스크럼 마스터(Scrum Master)
    - 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할
- 제품 백로그(Product Backlog)
    - 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함됨
- 스프린트(Sprint)
    - 하나의 완성된 최종 결과물을 만들기 위한 주기로 보통 2 ~ 4주 정도의 기간 내에서 진행함
- 속도(Velocity)
    - 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치

### XP(eXtreme Programming)
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화해 개발 생산성을 향상시키는 방법
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적
- 자동화된 테스팅 도구를 사용해 테스트를 지속적으로 수행

### XP의 핵심 가치
- 의사소통(Communication)
- 단순성(Simplicity)
- 용기(Courage)
- 존중(Respect)
- 피드백(Feedback)

### XP의 주요 실천 방법
- Pair Programming(짝 프로그래밍)
    - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성
- Collective Ownership(공동 코드 소유)
    - 개발 코드에 대한 권한과 책임을 공동으로 소유함
- Continuous Integration(지속적인 통합)
    - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 완료될 때마다, 지속적으로 통합됨
- Refactoring(리팩토링)
    - 프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템의 내부 구조를 재구성

### 현행 시스템 파악 절차
- 1단계 : 시스템 구성, 시스템 기능, 시스템 인터페이스 파악
- 2단계 : 아키텍처 구성, 소프트웨어(DBMS, 운영체제 등) 구성 파악
- 3단계 : 하드웨어 구성, 네트워크 구성 파악

### DBMS 분석 시 고려사항
- 가용성
- 성능
- 기술 지원
- 상호 호환성
- 구축 비용

### WAS(Web Application Server)
- 정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
- 종류 : Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등

### 비 기능 요구사항
- 성능 요구사항 : 처리 속도 및 시간, 처리량 등의 요구사항
- 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구사항
- 품질 요구사항 : 품질 평가 대상에 대한 요구사항

### 요구사항 개발 프로세스
```
도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
```

### 요구사항 분석
- 소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화(명세화) 하는 활동을 의미
- 사용자의 요구를 정확하게 추출해 목표를 정하고, 어떤 방식으로 해결할 것인지를 결정
- 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정
- 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 사용자의 요구사항은 예외가 많고 지속적으로 변하므로 열거와 구조화가 어려움
- 내용이 중복되거나 하나로 통합되어야 하는 등 서로 상충되는 요구사항이 있으면 이를 중재하는 과정
- 요구사항 분석을 위해 UML(Unified Modeling Language), 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등의 도구 이용

### 기능 요구사항
- 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
- 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

### 요구사항 명세 기법
```
구분        |       정형 명세 기법      |       비정형 명세 기법        |
기법        | 수학적 원리 기반          | 상태/기능/객체 중심
            | 모델 기반                | 
작성 방법   | 수학적 기호, 정형화된 표기법| 자연어를 기반으로 작성
            |                          | 다이어그램으로 작성
특징        | 요구사항 정확, 간결 표현  | 일관성이 떨어짐
            |                          | 의사소통이 용이함
종류        | VDM,Z,Petri-net,CSP 등   | FSM, Decision Table, ER 모델링, 
            |                           | State Chart(SADT) 등
```

### 요구사항 확인(요구사항 검증)
- 분석가가 요구사항을 정확하게 이해한 후 요구사항 명세서를 작성했는지 확인(Validation)하는 것이 필요
- 요구사항이 실제 요구를 반영하는지, 서로 상충되는 요구사항은 없는지 등을 점검
- 개발이 완료된 후, 문제가 발견되면 재작업 비용이 발생할 수 있으므로 요구사항 검증은 매우 중요
- 요구사항 검증 과정을 통해 모든 문제를 확인할 수 있는 것은 아님

### 자료 흐름도의 구성 요소
- 이 내용은 사진을 통해 알려주자

### 자료 사전의 표기 기호
```
기호           |        의미
=              | 자료의 정의 : ~로 구성되어 있다(is composed of)
+              | 자료의 연결 : 그리고(and)
()             | 자료의 생략 : 생략 가능한 자료(Optional)
[|]            | 자료의 선택 : 또는(or)
{}             | 자료의 반복 : Iteration of
* *            | 자료의 설명 : 주석(Comment)
```

### SADT
- SoftTech 사에서 개발한 구조적 분석 및 설계 도구
- 블록 다이어그램을 채택한 자동화 도구

### UML
- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간 의사소통이 원할하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
- 구성 요소 : 사물(Things), 관계(Relationships), 다이어그램(Diagram)

### HIPO
- 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
- 하향식 소프트웨어 개발을 위한 문서화 도구
- 기호, 도표 등을 사용하므로 보기 쉽고 이해가 쉬움
- 기능과 자료의 의존 관계를 동시 표현 가능
- 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 함
- HIPO Chart의 종류 : 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)

### 의존(Dependency) 관계
- 연관 관계와 같이 사물 사이 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 의미
- 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우 나타나는 관계

### 실체화(Realization) 관계
- 사물이 할 수 있거나 해야 하는 기능(오퍼레이션, 인터페이스)로 서로를 그룹화 할 수 있는 관계를 표현
- 한 사물이 다른 사물에게 오퍼레이션을 수행하도록 지정하는 의미적 관계

### 일반화(Generalization) 관계
- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
- 예를 들어 차는 버스, 트럭, 택시보다 일반적인 개념이고 반대로 버스, 트럭, 택시는 차보다 구체적인 개념

### 스테레오 타입(Stereotype)
- UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용
- 길러멧(Guilemet)이라고 부르는 겹화살괄호(<<>>) 사이에 표현할 형태를 기술

### 구조적(정적) 다이어그램
- 클래스 다이어그램
    - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현하며, 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있음
- 객체(Object) 다이어그램
    - 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현하며, 구현 단계에서 사용됨
- 컴포넌트 다이어그램
    - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현하며, 구현 단계에서 사용됨
- 배치(Deployment) 다이어그램
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현하며, 구현 단계에서 사용됨
- 복합체 구조(Composite Structure) 다이어그램
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함
- 패키지 다이어그램
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

### 사용자 인터페이스(UI)의 특징
- 사용자의 편리성과 가독성을 높임으로써 작업 시간을 단축시키고 업무에 대한 이해도를 높여줌
- 사용자 중심으로 설계되어 사용자 중심의 상호 작용이 되도록 함
- 수행 결과의 오류를 줄임
- 사용자의 막연한 작업 기능에 대해 구체적인 방법을 제시해 줌

### 행위(동적) 다이어그램
- 유스케이스 다이어그램
    - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
- 순차(Sequence) 다이어그램
    - 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
- 커뮤니케이션 다이어그램
    - 순차 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현
- 상태(State) 다이어그램
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현하는 것으로, 럼바우 객체지향 분석 기법에서 동적 모델링에 활용
- 활동(Activity) 다이어그램
    - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현함
- 상호작용 개요(Interaction Overview) 다이어그램
    - 상호작용 다이어그램 간 제어 흐름을 표현
- 타이밍 다이어그램
    - 객체 상태 변화와 시간 제약을 명시적으로 표현

### 유스케이스 다이어그램의 구성 요소
- 시스템 / 시스템 범위
    - 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
- 액터  
`시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미`  
    - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당
    - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있음
- 유스케이스
    - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현
- 관계(Relationship)
    - 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며, 연관 관계, 포함 관계, 확장 관계, 일반화 관계를 표현할 수 있음

### 오퍼레이션(Operation)
- 클래스가 수행할 수 있는 동작으로, 함수(메소드)라고도 함

### 순차 다이어그램의 구성 요소
- 액터(Actor)
- 객체(Object)
- 생명선(Lifeline)
- 실행 상자(Active Box)
- 메시지(Message)

### 사용자 인터페이스의 구분
- CLI(Command Line Interface)
    - 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphic User Interface)
    - 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface)
    - 사용자의 말이나 행동으로 기기를 조작하는 인터페이스

### 목업(Mockup)
- 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임 보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
- 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않음

### 주요 모바일 제스처(Mobile Gesture)
- Tap(누르기)
    - 화면을 가볍에 한 번 터치하는 동작
- Double Tap(두번 누르기)
    - 화면을 빠르게 두 번 터치하는 동작
- Press(오래 누르기)
    - 화면의 특정 위치를 손가락으로 꾹 눌리는 동작
- Flick(빠르게 스크롤)
    - 화면에 손가락을 터치하면서 수평 또는 수직으로 빠르게 드래그하는 동작
- Pinch(두 손가락으로 넓히기/좁히기)
    - 두 손가락으로 화면을 터치한 후 두 손가락을 서로 다른 방향으로 움직이는 동작

### 사용자 인터페이스의 원칙 - 직관성
- 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙

### 사용자 인터페이스 설계 지침
- 사용자 중심
    - 사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경을 제공하며, 실사용자에 대한 이해가 바탕이 되어야 함
- 사용성
    - 사용자가 소프트웨어를 얼마나 빠르고 쉽게 이해할 수 있는지, 얼마나 편리하고 효율적으로 사용할 수 있는지를 말하는 것으로, 사용자 인터페이스 설계시 가장 우선적으로 고려해야 함
- 가시성
    - 메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계해야 함
- 심미성
    - 디자인적으로 완성도 높게 글꼴이나 색상을 적용하고 그래픽 요소를 배치하여 가독성을 높일 수 있도록 설계해야 함
- 접근성
    - 사용자의 연령, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계해야 함
- 오류 발생 해결
    - 오류가 발생하면 사용자가 쉽게 인지할 수 있도록 설계해야 함

### ISO/IEC 12119
- ISO/IEC 9126을 준수한 품질 표준, 테스트 절차를 포함하여 규정
- 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준

### 소프트웨어 품질 특성 - 기능성(Functionality)
- 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄
- 하위 특성
    - 적절성/적합성, 정밀성/정확성, 상호운용성, 보안성, 준수성

### 소프트웨어 품질 특성 - 신뢰성(Reliability)
- 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도를 나타냄

### 소프트웨어 품질 특성 - 사용성(Usability)
- 사용자와 컴퓨터 사이 발생하는 어떤 행위에 대해 사용자가 쉽게 배우고 사용할 수 있으며, 향후 다시 사용하고 싶은 정도를 나타냄

### 소프트웨어 품질 특성 - 이식성(Portability)
- 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타냄

### UI 요소 - 라디오 버튼
- 여러 항목 중 하나만 선택할 수 있는 사용자 인터페이스 요소

### 소프트웨어 아키텍처의 설계 과정
```
설계 목표 설정 -> 시스템 타입 결정 -> 아키텍처 패턴 적용 -> 서브시스템 구체화 -> 검토
```

### 모듈화(Modularity)
- 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
- 모듈화를 통해 기능의 분리가 가능하여 인터페이스가 단순해진다.
- 모듈화를 통해 프로그램의 효율적인 관리가 가능하고 오류의 파급 효과를 최소화 가능
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 듬

### 추상화의 유형
- 과정 추상화
- 데이터(자료) 추상화
- 제어 추상화

### 파이프 - 필터 패턴
- 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
- 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생

### MVC(Model-View-Controller) 패턴
- 모델
    - 서브시스템의 핵심 기능과 데이터를 보관
- 뷰
    - 사용자에게 정보를 표시
- 컨트롤러
    - 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

### 메시지(Message)
- 객체들 간 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항

### 클래스(Class)
- 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라 함

### 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음
- 캡슐화를 수행하면 인터페이스가 단순해짐
- 캡슐화된 객체들은 재사용이 용이

### 상속(Inheritance)
- 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것

### 객체지향 분석 방법론 - Coad와 Yourdon 방법
- E-R 다이어그램을 사용해 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법

### 럼바우(Rumbaugh)의 분석 기법
- 객체(Object) 모델링
    - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
- 동적(Dynamic) 모델링
    - 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
- 기능(Functional) 모델링
    - 자료 흐름도(DFD)를 이용해 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체지향 설계 원칙(SOLID) 원칙
- 단일 책임 원칙(SRP; Single Responsibility Principle)
    - 객체는 단 하나의 책임만 가져야 한다는 원칙으로, 응집도는 높고, 결합도는 낮게 설계하는 것을 의미
- 개방 폐쇄 원칙(OCP; Open-Closed Principle)
    - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙으로, 공통 인터페잇를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적
- 리스코프 치환 원칙(LSP; Liskov Substitution Principle)
    - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙으로, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야함
- 인터페이스 분리 원칙(ISP; Interface Segregation Principle)
    - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙으로, 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임
- 의존 역전 원칙(DIP; Dependency Inversion Principle)
    - 각 객체들 간 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙으로, 일반적으로 인터페이스를 활용하면 이 원칙은 준수됨

### 모듈(Module)
- 모듈화를 통해 분리된 시스템의 각 기능들로, 서브 루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨
- 모듈은 단독으로 컴파일이 가능하며, 재사용 할 수 있음
- 모듈은 다른 모듈에서의 접근이 가능

### 결합도의 종류
- 자료(Data) 결합도
    - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
- 스탬프(Stamp) 결합도
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
- 제어(Control) 결합도
    - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용해 통신하거나 제어 요소를 전달하는 결합도
- 외부(External) 결합도
    - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
- 공통(Common) 결합도
    - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
- 내용(Content) 결합도
    - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

### 결합도의 정도(약함->강함)
```
자로 결합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도
```

### 응집도의 정도(약함->강함)
```
우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 교환적 응집도 -> 순차적 응집도 -> 기능적 응집도
```

### 응집도의 종류
- 기능적(Functional) 응집도
    - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
- 순차적(Sequential) 응집도
    - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
- 교환적(Communication) 응집도
    - 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
- 절차적(Procedural) 응집도
    - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- 시간적(Temporal) 응집도
    - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
- 논리적(Logical) 응집도
    - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
- 우연적(Coincidental) 응집도
    - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

### N-S 차트(Nassi-Schneiderman Chart)
- 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고도 함
- 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현
- GOTO나 화살표를 사용하지 않음
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
- 이해하기 쉽고, 코드 변환이 용이

### 재사용(Reuse)
- 이미 개발된 기능을 새로운 시스템이나 기능 개발에 사용할 수 있는 정도를 의미
- 재사용 규모에 따른 분류
    - 함수와 객체, 컴포넌트, 애플리케이션

### 팬인(Fan-In) / 팬아웃(Fan-Out)
- 팬인
    - 어떤 모듈을 제어(호출)하는 모듈의 수
- 팬아웃
    - 어떤 모듈에 의해 제어(호출)되는 모듈의 수

### 효과적인 모듈 설계 방안
- 결합도는 줄이고 응집도는 높여 모듈의 독립성과 재사용성을 높임
- 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지 시킴
- 복잡도의 중복성을 줄이고 일관성을 유지
- 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안됨
- 유지보수가 용이해야 함

### 디자인 패턴(Design Pattern)
- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
- 디자인 패턴 유형
    - 생성 패턴, 구조 패턴, 행위 패턴

### 생성 패턴(Creational Pattern)
- 추상 팩토리(Abstract Factory)
    - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 빌더(Builder)
    - 작게 분리된 인스턴스를 건축 하듯 조합하여 객체를 생성
- 팩토리 메서드(Factory Method)
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화된 패턴으로, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당. 가상 생성자(Virtual Constructor)패턴 이라고도 함
- 프로토 타입(Prototype)
    - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤(Singleton)
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음

### 구조 패턴(Structural Pattern)
- 어댑터(Adapter)
    - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지(Bridge)
    - 구현부에서 최상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트(Composite)
    - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 데코레이터(Decorator)
    - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴으로, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
- 퍼싸드(Facade)
    - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 플라이웨이트(Flyweight)
    - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 프록시(Proxy)
    - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

### 행위 패턴(Behavioral Pattern)
- 책임 연쇄(Chain of Responsibility)
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 커맨드(Command)
    - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 인터프리터(Interpreter)
    - 언어에 문법 표현을 정의하는 패턴으로, SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함
- 반복자(Iterator)
    - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자(Mediator)
    - 수많은 객체들 간 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
- 메멘토(Memento)
    - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있느 기능을 제공하는 패턴으로 Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 사용
- 옵저버(Observer)
    - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 상태(State)
    - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략(Strategy)
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 템플릿 메소드(Template Method)
    - 상위 클래스에서 골격을 정의하고, 하위 클래승서 세부 처리를 구체화하는 구조의 패턴
- 방문자(Visitor)
    - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

### 요구사항 검증 방법
- 동료검토(Peer Review)
    - 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으며 결함을 발견하는 형태의 검토 방법
- 워크스루(Walk Through)
    - 검토 회의 전 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법
- 인스펙션(Inspection)
    - 요구사항 명셋 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하며 결함을 발견하는 형태의 검토 방법
- 동료검토와 워크스루가 비공식적인 검토 방법인데 반해 인스펙션은 공식적인 검토 방법

### 미들웨어(Middleware)
- 분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신 환경 등을 연결
- 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 원만한 통신이 이루어지도록 다양한 서비스를 제공
- 위치 투명성을 제공
- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 함
- 시스템들을 1:1, 1:N, N:M 등 여러 가지 형태로 연결할 수 있음
- 종류 : DB, RPC, MOM, TP-Monitor, ORB, WAS 등

## 제 2과목 소프트웨어 개발

### 자료 구조의 분류
- 선형 구조 : 배열(Array), 선형 리스트(Linear List), 스택(Stack), 큐(Queue), 데크(Deque)
- 비 선형 구조 : 트리(Tree), 그래프(Graph)

### 스택(Stack)
- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리

### 스택의 응용 분야
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀 주소 저장
- 서브루틴 호출 및 복귀 주소 저장

### 스택의 삽입(Push)과 삭제(Pop)
- PUSH는 스택에 자료를 입력하는 명령이고, POP은 스택에서 자료를 출력하는 명령

### 방향/무방향 그래프의 최대 간선 수
- n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2이고, 방향 그래프에서 최대 간선 수는 n(n-1)이다.

### 트리(Tree)
